{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/wixo/source/js/tocgenerator.min.js","path":"js/tocgenerator.min.js","modified":1},{"_id":"themes/wixo/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/wixo/source/js/jquery.tableofcontents.min.js","path":"js/jquery.tableofcontents.min.js","modified":1},{"_id":"themes/wixo/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/wixo/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/wixo/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/wixo/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1},{"_id":"themes/wixo/source/img/glyphicons-halflings.png","path":"img/glyphicons-halflings.png","modified":1},{"_id":"themes/wixo/source/img/glyphicons-halflings-white.png","path":"img/glyphicons-halflings-white.png","modified":1},{"_id":"themes/wixo/source/img/github-sprite.png","path":"img/github-sprite.png","modified":1},{"_id":"themes/wixo/source/fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","path":"fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","modified":1},{"_id":"themes/wixo/source/fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","path":"fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","modified":1},{"_id":"themes/wixo/source/fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","path":"fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","modified":1},{"_id":"themes/wixo/source/fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","path":"fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","modified":1},{"_id":"themes/wixo/source/fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","path":"fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","modified":1},{"_id":"themes/wixo/source/fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","path":"fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","modified":1},{"_id":"themes/wixo/source/fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","path":"fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","modified":1},{"_id":"themes/wixo/source/fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","path":"fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","modified":1},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/wixo/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1},{"_id":"themes/wixo/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/wixo/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/wixo/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/wixo/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/wixo/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/wixo/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/wixo/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/wixo/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/wixo/source/css/style.css","path":"css/style.css","modified":1},{"_id":"themes/wixo/source/css/sidenav.css","path":"css/sidenav.css","modified":1},{"_id":"themes/wixo/source/css/responsive.css","path":"css/responsive.css","modified":1},{"_id":"themes/wixo/source/css/highlight.css","path":"css/highlight.css","modified":1},{"_id":"themes/wixo/source/css/google-fonts.css","path":"css/google-fonts.css","modified":1},{"_id":"themes/wixo/source/css/font-awesome.css","path":"css/font-awesome.css","modified":1},{"_id":"themes/wixo/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1},{"_id":"themes/wixo/source/css/bootstrap-responsive.css","path":"css/bootstrap-responsive.css","modified":1},{"_id":"source/images/thesis2/image5.png","path":"images/thesis2/image5.png","modified":1},{"_id":"source/images/thesis2/image4.png","path":"images/thesis2/image4.png","modified":1},{"_id":"source/images/thesis2/image3.png","path":"images/thesis2/image3.png","modified":1},{"_id":"source/images/thesis2/image2.png","path":"images/thesis2/image2.png","modified":1},{"_id":"source/images/thesis2/image1.png","path":"images/thesis2/image1.png","modified":1},{"_id":"source/images/thesis2/Thumbs.db","path":"images/thesis2/Thumbs.db","modified":1},{"_id":"source/images/thesis/ds.png","path":"images/thesis/ds.png","modified":1},{"_id":"source/images/thesis/chapter3/FINGERPRINT1.jpg","path":"images/thesis/chapter3/FINGERPRINT1.jpg","modified":1},{"_id":"source/images/thesis/chapter3/9.bmp","path":"images/thesis/chapter3/9.bmp","modified":1},{"_id":"source/images/thesis/chapter3/8.bmp","path":"images/thesis/chapter3/8.bmp","modified":1},{"_id":"source/images/thesis/chapter3/7.bmp","path":"images/thesis/chapter3/7.bmp","modified":1},{"_id":"source/images/thesis/chapter3/6.graffle","path":"images/thesis/chapter3/6.graffle","modified":1},{"_id":"source/images/thesis/chapter3/6.bmp","path":"images/thesis/chapter3/6.bmp","modified":1},{"_id":"source/images/thesis/chapter3/5.png","path":"images/thesis/chapter3/5.png","modified":1},{"_id":"source/images/thesis/chapter3/4.graffle","path":"images/thesis/chapter3/4.graffle","modified":1},{"_id":"source/images/thesis/chapter3/4.bmp","path":"images/thesis/chapter3/4.bmp","modified":1},{"_id":"source/images/thesis/chapter3/3.graffle","path":"images/thesis/chapter3/3.graffle","modified":1},{"_id":"source/images/thesis/chapter3/3.bmp","path":"images/thesis/chapter3/3.bmp","modified":1},{"_id":"source/images/thesis/chapter3/2.graffle","path":"images/thesis/chapter3/2.graffle","modified":1},{"_id":"source/images/thesis/chapter3/2.bmp","path":"images/thesis/chapter3/2.bmp","modified":1},{"_id":"source/images/thesis/chapter3/10.graffle","path":"images/thesis/chapter3/10.graffle","modified":1},{"_id":"source/images/thesis/chapter3/10.bmp","path":"images/thesis/chapter3/10.bmp","modified":1},{"_id":"source/images/thesis/chapter3/1.graffle","path":"images/thesis/chapter3/1.graffle","modified":1},{"_id":"source/images/thesis/chapter3/1.bmp","path":"images/thesis/chapter3/1.bmp","modified":1},{"_id":"source/images/thesis/chapter1/7.graffle","path":"images/thesis/chapter1/7.graffle","modified":1},{"_id":"source/images/thesis/chapter1/7.bmp","path":"images/thesis/chapter1/7.bmp","modified":1},{"_id":"source/images/thesis/chapter1/6.bmp","path":"images/thesis/chapter1/6.bmp","modified":1},{"_id":"source/images/thesis/chapter1/5.bmp","path":"images/thesis/chapter1/5.bmp","modified":1},{"_id":"source/images/thesis/chapter1/4.bmp","path":"images/thesis/chapter1/4.bmp","modified":1},{"_id":"source/images/thesis/chapter1/3.bmp","path":"images/thesis/chapter1/3.bmp","modified":1},{"_id":"source/images/thesis/chapter1/2.graffle","path":"images/thesis/chapter1/2.graffle","modified":1},{"_id":"source/images/thesis/chapter1/2.bmp","path":"images/thesis/chapter1/2.bmp","modified":1},{"_id":"source/images/thesis/chapter1/1.bmp","path":"images/thesis/chapter1/1.bmp","modified":1},{"_id":"source/images/thesis/Thumbs.db","path":"images/thesis/Thumbs.db","modified":1},{"_id":"source/images/thesis/5.jpg","path":"images/thesis/5.jpg","modified":1},{"_id":"source/images/thesis/4.jpg","path":"images/thesis/4.jpg","modified":1},{"_id":"source/images/thesis/3.jpg","path":"images/thesis/3.jpg","modified":1},{"_id":"source/images/thesis/2.jpg","path":"images/thesis/2.jpg","modified":1},{"_id":"source/images/thesis/1.png","path":"images/thesis/1.png","modified":1},{"_id":"source/images/Thumbs.db","path":"images/Thumbs.db","modified":1},{"_id":"source/images/9.png","path":"images/9.png","modified":1},{"_id":"source/images/8.png","path":"images/8.png","modified":1},{"_id":"source/images/7.png","path":"images/7.png","modified":1},{"_id":"source/images/6.png","path":"images/6.png","modified":1},{"_id":"source/images/5.png","path":"images/5.png","modified":1},{"_id":"source/images/4.png","path":"images/4.png","modified":1},{"_id":"source/images/3.png","path":"images/3.png","modified":1},{"_id":"source/images/2.png","path":"images/2.png","modified":1},{"_id":"source/images/1.png","path":"images/1.png","modified":1}],"Cache":[{"_id":"source/_posts/150703-thesis.md","shasum":"0bd939a06bbbd0e0ba4b0931394b3c441d1b6c0e","modified":1436434077836},{"_id":"source/_posts/150709-JS.md","shasum":"c8012366b7f2063a4f6c83489682bd4c6af6cee7","modified":1436434077839},{"_id":"source/_posts/1Introduction.md","shasum":"939973a5d02bdc4b9a290578097311774f75db4a","modified":1436434077856},{"_id":"source/_posts/3System-Architecture.md","shasum":"996c0012f72e6367c90ec2916d7fc60c58b7d557","modified":1436434077858},{"_id":"source/_posts/4Security-Strategy.md","shasum":"8701015fa6dd8688e5b20db4227c62e67b157c7a","modified":1436434077860},{"_id":"source/_posts/Algorithm.md","shasum":"caae6bfcc1ff858a08801710900aa7e309eab8bb","modified":1436434077862},{"_id":"source/_posts/CodeTest.md","shasum":"be0d6b10a8576f389890058b35d3c8e8753fd6b5","modified":1436434077865},{"_id":"source/_posts/Nancy-Framework.md","shasum":"ed38e62d171a96ed1378790ad6b40ad0acfaa8a7","modified":1436434077867},{"_id":"source/_posts/Welcome.md","shasum":"b629011e6716f77b1a3dd5638ec2deab8df293da","modified":1436434077869},{"_id":"source/_posts/hello-world.md","shasum":"167620db180cec719cce41d552c40ad594dac4c6","modified":1436434077870},{"_id":"source/_posts/thesis.md","shasum":"9251030111ae04a0d9dd27bd72e388975ba77eba","modified":1436434077873},{"_id":"source/images/3.png","shasum":"7d130ae550dfecddf62ea2f106fbd5804f050c80","modified":1436434077879},{"_id":"source/images/4.png","shasum":"f4d891ee177680a65a519a6a204e9c3b57b99d2f","modified":1436434077880},{"_id":"source/images/5.png","shasum":"37b090c2d1550249ae8b72dbb3277a6f422a7634","modified":1436434077924},{"_id":"source/images/6.png","shasum":"e471a2429094a3e4d4a9a34eada12df8c5f37efc","modified":1436434077925},{"_id":"source/images/7.png","shasum":"32ceb42b2a52d6cdb40b53301711448de8e12e5c","modified":1436434077925},{"_id":"source/images/8.png","shasum":"5756bf3f15ddf227e4dbc6640b52d4e55ecfc080","modified":1436434077926},{"_id":"source/images/9.png","shasum":"0adcf27a107a33723cf2aea07b98d5b57675c6c6","modified":1436434077927},{"_id":"source/images/thesis/1.png","shasum":"36fbd4b58e5a1c0c69f336308bf72455cee0405f","modified":1436434077945},{"_id":"source/images/thesis/2.jpg","shasum":"fbf5e36951c97d925dd6df375b594f9f0aa49eff","modified":1436434077948},{"_id":"source/images/thesis/3.jpg","shasum":"777ae5ae5e89087a604b2b5ce7c5def85c39cfe6","modified":1436434077950},{"_id":"source/images/thesis/4.jpg","shasum":"feb542787c2228a363c96c84cb1b377597b912c6","modified":1436434077952},{"_id":"source/images/thesis/5.jpg","shasum":"f2a2d1956228c9acf9a5bd97ae12ee9fbe368a89","modified":1436434077984},{"_id":"source/images/thesis/Thumbs.db","shasum":"448fa1516927dc4b9938ee6d9ae485ccc2ab953d","modified":1436434077987},{"_id":"source/images/thesis/chapter1/2.graffle","shasum":"e9c261946ecc4817ffded3b71db57f5cacaff127","modified":1436434077999},{"_id":"source/images/thesis/chapter1/7.graffle","shasum":"3dc591012f48c2665ff0c7affb7b3f4ae3e3c968","modified":1436434078077},{"_id":"source/images/thesis/chapter3/10.graffle","shasum":"0e179aefb8c4e323f6c6c9f9b1d7bd3f5125bedb","modified":1436434078122},{"_id":"source/images/thesis/chapter3/2.graffle","shasum":"47bcfe2e6966277da7a9f1bd344231010bef6d69","modified":1436434078129},{"_id":"source/images/thesis/chapter3/3.graffle","shasum":"1a9eeb16fe6d2be8cd40c2e3ffc3d7fcba521615","modified":1436434078133},{"_id":"source/images/thesis/chapter3/4.graffle","shasum":"5c41e5c5cddc016e31518c07a0adcfe2872a2951","modified":1436434078140},{"_id":"source/images/thesis/chapter3/5.png","shasum":"4eacd646c70c1c333409c5144eaab27b87ab80b4","modified":1436434078140},{"_id":"source/images/thesis/chapter3/6.graffle","shasum":"d0b08c3864057aa5e9ca7f4c1850ac55debe2e42","modified":1436434078147},{"_id":"source/images/thesis/ds.png","shasum":"82b898e849ce8f678085ba5bf9d5b3a746eb6f47","modified":1436434078169},{"_id":"source/images/thesis2/Thumbs.db","shasum":"55acda27881da2d32faff4736f13520e58eeb45e","modified":1436434078175},{"_id":"source/images/thesis2/image1.png","shasum":"2203356a482f276b719571a7f0f3eb164c5911fa","modified":1436434078177},{"_id":"source/images/thesis2/image2.png","shasum":"9b7bca3ba5b4119ccd9c44afb7f2ff2c31afa423","modified":1436434078178},{"_id":"source/images/thesis2/image3.png","shasum":"70e01e42fecbb9803ad2dfff93803820383428fc","modified":1436434078179},{"_id":"source/images/1.png","shasum":"6b91a7ca6d92e0ade66aff5222a4a7657d624b98","modified":1436434077877},{"_id":"source/images/2.png","shasum":"75f6174ee7a74cb004f64679676f67681ef76367","modified":1436434077879},{"_id":"source/images/Thumbs.db","shasum":"8231fe0f58eec9e54138e5db39424b5cc2afb413","modified":1436434077940},{"_id":"source/images/thesis2/image4.png","shasum":"04e10b937e06d7a2be7e772ac3e8b71334759ff1","modified":1436434078201},{"_id":"source/images/thesis2/image5.png","shasum":"1b7886903adc15b2687d6ea77026b2bab4c44e62","modified":1436434078203},{"_id":"themes/wixo/LICENSE","shasum":"4c3f507519574b22886c185c0114bc49bd4eb22e","modified":1436434078593},{"_id":"themes/wixo/README.md","shasum":"3f5b23a6fc7151e2f39e1584ab424c608f6a5fb1","modified":1436434078597},{"_id":"themes/wixo/_config.yml","shasum":"55633c15147f551c6e657e5294363043b577342f","modified":1436434078600},{"_id":"themes/wixo/layout/_partial/after_footer.ejs","shasum":"615a6b68e49b7c9f936fa90c5cd627d8cfcf2fe3","modified":1436434078607},{"_id":"themes/wixo/layout/_partial/article.ejs","shasum":"f821f31ee7b66ecf509fb8fdd30eef8e2c9e8155","modified":1436434078612},{"_id":"themes/wixo/layout/_partial/footer.ejs","shasum":"45f673385bdd0908bd912718e6050fcd1fd84077","modified":1436434078614},{"_id":"themes/wixo/layout/_partial/head.ejs","shasum":"1964f860333944550209b3f90dca82b9f61d6ed4","modified":1436434078620},{"_id":"themes/wixo/layout/_partial/index.ejs","shasum":"9f67a1e6f690912d16ff9ec5bb3deefe4c86712e","modified":1436434078628},{"_id":"themes/wixo/layout/_partial/mathjax.ejs","shasum":"55003848270e8d0d1e6e66f7bab265ec4606b70d","modified":1436434078655},{"_id":"themes/wixo/layout/_partial/post/google_analytics.ejs","shasum":"061c10627d648b527c2cd0575f29fac7c9c4b831","modified":1436434078658},{"_id":"themes/wixo/layout/_partial/post/pagination.ejs","shasum":"a121f7c2c7278167ce0b4b7d90dd680343eaf971","modified":1436434078663},{"_id":"themes/wixo/layout/_partial/post/toc.ejs","shasum":"332c033a4b8147ce9e4c7fb6acd1a0468b03ef6a","modified":1436434078666},{"_id":"themes/wixo/layout/index.ejs","shasum":"0fc2488aa7cd3165f16f7de49d7efc7ed6b524b1","modified":1436434078668},{"_id":"themes/wixo/layout/layout.ejs","shasum":"693794e0dbcbeae9bf499daf14ee2ccfe643340b","modified":1436434078670},{"_id":"themes/wixo/layout/page.ejs","shasum":"21612a42b29cb20f106bc2716c598e69db142750","modified":1436434078672},{"_id":"themes/wixo/source/css/bootstrap-responsive.css","shasum":"4f241755f6192c31cf35f0b0f919d918d96a6eee","modified":1436434078676},{"_id":"themes/wixo/source/css/font-awesome.css","shasum":"edf2017cce9bd3dac2d9936bc4bd909471893733","modified":1436434078708},{"_id":"themes/wixo/source/css/google-fonts.css","shasum":"72e8af5cd1aed1ff7288cc360b768f623b201848","modified":1436434078709},{"_id":"themes/wixo/source/css/highlight.css","shasum":"9b2aee2d58407934334bbe23d7db4a5c1910ac9c","modified":1436434078710},{"_id":"themes/wixo/source/css/responsive.css","shasum":"a4b398d5454222b5b5cc8cc998012ceb2a57ccda","modified":1436434078712},{"_id":"themes/wixo/source/css/sidenav.css","shasum":"524526c4d8e81defcafd25f224604751defaf65c","modified":1436434078713},{"_id":"themes/wixo/source/css/style.css","shasum":"6870dbf2d0e13c40c18041d4f41cfc63f1e6e633","modified":1436434078717},{"_id":"themes/wixo/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1436434078717},{"_id":"themes/wixo/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1436434078718},{"_id":"themes/wixo/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1436434078719},{"_id":"themes/wixo/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1436434078757},{"_id":"themes/wixo/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1436434078759},{"_id":"themes/wixo/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1436434078760},{"_id":"themes/wixo/source/fancybox/jquery.fancybox.css","shasum":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1436434078762},{"_id":"themes/wixo/source/fancybox/jquery.fancybox.pack.js","shasum":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1436434078776},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.eot","shasum":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1436434078798},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.woff","shasum":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1436434078830},{"_id":"themes/wixo/source/fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","shasum":"1d9bb14c006d39d7eb0812a85567c7431f899b8d","modified":1436434078833},{"_id":"themes/wixo/source/fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","shasum":"33225e85c33279e7b4f0c5c65ff93bec740dd59c","modified":1436434078879},{"_id":"themes/wixo/source/fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","shasum":"87deb174af2e2beebb9f09d618a5159ca299a3d0","modified":1436434078882},{"_id":"themes/wixo/source/fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","shasum":"f401d51152681048c06187c5d3919b1407b899c5","modified":1436434078885},{"_id":"themes/wixo/source/fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","shasum":"18dc51e642b4df958098d3bbc6d3ba0237ef6150","modified":1436434078889},{"_id":"themes/wixo/source/fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","shasum":"d9f913d09bb3c25749daf8e7ab829c850a842929","modified":1436434078892},{"_id":"themes/wixo/source/fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","shasum":"17a484b92c0dacc8e8b4f0d38ccc1db400819d1d","modified":1436434078895},{"_id":"themes/wixo/source/fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","shasum":"e6c9f1e5a6a966a8f7250201356f351890a48921","modified":1436434078901},{"_id":"themes/wixo/source/img/github-sprite.png","shasum":"4d7ee33beaaebf002ba57a172d159e46194ae481","modified":1436434078903},{"_id":"themes/wixo/source/img/glyphicons-halflings-white.png","shasum":"a25c4705320fd63c33790e666872910e702b9bf6","modified":1436434078904},{"_id":"themes/wixo/source/img/glyphicons-halflings.png","shasum":"84f613631b07d4fe22acbab50e551c0fe04bd78b","modified":1436434078942},{"_id":"themes/wixo/source/js/bootstrap.min.js","shasum":"9933cdc70c0047a3ea1a196f9320c36737b93c2a","modified":1436434078952},{"_id":"themes/wixo/source/js/gallery.js","shasum":"53c6538ae764f8fa922ff57028f14a20a8a2edb8","modified":1436434078956},{"_id":"themes/wixo/source/js/jquery.imagesloaded.min.js","shasum":"3eb6381d2ed4b706020e4be5aff024aab4bcabc5","modified":1436434079007},{"_id":"themes/wixo/source/js/jquery.tableofcontents.min.js","shasum":"38a3cbc147d4d639596cdda07d88f4e052ef31b0","modified":1436434079008},{"_id":"themes/wixo/source/js/main.js","shasum":"ca765ef0a5ea4e57b5208f5f2ad80da0d8559cce","modified":1436434079009},{"_id":"themes/wixo/source/js/tocgenerator.min.js","shasum":"68185d301670cbad859c987428b08c4efd473947","modified":1436434079010},{"_id":"themes/wixo/source/css/bootstrap.min.css","shasum":"b982b68f818bba6fc9fead73d25d96a48972311e","modified":1436434078678},{"_id":"themes/wixo/source/fonts/FontAwesome.otf","shasum":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1436434078782},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.ttf","shasum":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1436434078826},{"_id":"themes/wixo/source/js/jquery-2.0.3.min.js","shasum":"3dad20239301f9ee22f22ca7d5ac6eca1da4ac22","modified":1436434078980},{"_id":"source/images/thesis/chapter3/1.graffle","shasum":"ae32342b67a4eb7c247dff791baeb2517545a01e","modified":1436434078087},{"_id":"source/images/thesis/chapter3/FINGERPRINT1.jpg","shasum":"392658b3f2eb4d5b954ede44673ec51be9c9f95e","modified":1436434078168},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.svg","shasum":"e471023286b7dd1d2ccc72f670a471cfdfeafab7","modified":1436434078823},{"_id":"source/images/thesis/chapter1/1.bmp","shasum":"c87ccd092faeea8313e2298406e092b215b350f4","modified":1436434077994},{"_id":"source/images/thesis/chapter1/3.bmp","shasum":"a2109fa0268081bf250e4952cfdf29577548b840","modified":1436434078003},{"_id":"source/images/thesis/chapter1/4.bmp","shasum":"2c883e7a6c026f818423df600a3d702d7c615805","modified":1436434078006},{"_id":"source/images/thesis/chapter1/5.bmp","shasum":"ca10261d4cfdb3bec5c0bb2d29715ecc85708244","modified":1436434078067},{"_id":"source/images/thesis/chapter1/6.bmp","shasum":"5793a5ad540d7e01021f6314c91f0942d1369155","modified":1436434078071},{"_id":"source/images/thesis/chapter1/2.bmp","shasum":"2fdde5e96387c8827e1083fa8e072b7d861b88df","modified":1436434077997},{"_id":"source/images/thesis/chapter1/7.bmp","shasum":"37d45d82add520f595b847df26a1826d97c09255","modified":1436434078075},{"_id":"source/images/thesis/chapter3/3.bmp","shasum":"8908900fe82f40f060f15e2ce5f2df2cc54cff37","modified":1436434078133},{"_id":"source/images/thesis/chapter3/2.bmp","shasum":"c0a1533791e5a6f681e131058b51054c4bdf8fe6","modified":1436434078127},{"_id":"source/images/thesis/chapter3/7.bmp","shasum":"e1bc7ad26fb82205a0c7cf565d5c0689fa7f5335","modified":1436434078153},{"_id":"source/images/thesis/chapter3/10.bmp","shasum":"2993189c17d2b6529a5c95969de0656e610c6ae3","modified":1436434078093},{"_id":"source/images/thesis/chapter3/4.bmp","shasum":"7238eb33ad52fe18978e708e9608083322fcac95","modified":1436434078137},{"_id":"source/images/thesis/chapter3/9.bmp","shasum":"60ec60ce37d0abcd9ad6a407d84f8f8a939d0188","modified":1436434078164},{"_id":"source/images/thesis/chapter3/1.bmp","shasum":"21d210951a8f195dcdf9ff23b0bc30d7506704b5","modified":1436434078084},{"_id":"source/images/thesis/chapter3/8.bmp","shasum":"f9a674e2db6a908e10ffc9607d9d9ac8a200f1e7","modified":1436434078159},{"_id":"source/images/thesis/chapter3/6.bmp","shasum":"f734c0f637463b9f69c645c62f3fea5a7b6b47aa","modified":1436434078147}],"Category":[{"name":"Thesis (English Verion)","_id":"cibw03geb0001n8svt3xoeg5v"},{"name":"Zhang's Thesis","_id":"cibw03geq0006n8svnissgedy"},{"name":"Guide","_id":"cibw03ges000an8svcxdspqsk"},{"name":"Thesis","_id":"cibw03gex000fn8svkmyc54g9"},{"name":"Javascript","_id":"cibw03gez000jn8svgp4qi72t"}],"Data":[],"Page":[],"Post":[{"title":"thesis","date":"2015-07-03T07:48:53.000Z","toc":true,"_content":"# 1 Introduction\nThis part has been done.However, It need some modification later. [Chapter 1](http://lichcnpul.github.io/2015/06/22/1Introduction/)\n## 1.1 Fingerprint Certification System\nFingerprint identification system is an important identity authentication system. It will be more and more important in modern society. Traditional fields such as security system, access control system must use this technology. With the rise of the mobile Internet, more and more emerging fields such as e-commerce, electronic payment also need this technology.\n\nThe traditional fingerprint recognition system adopts the following technical architecture:\n![figure 1](/images/1.png)\nThe business process is as follows:\n1. Users press the fingerprints on the fingerprints sensor.\n2. The sensor is connected to the computer system and sends the user’s fingerprints directly to the computer system.\n3. The similarity of fingerprint data between user and database will be compared.\n4. The fingerprint authentication system judges whether the user is authenticated by the similarity and returns the result to the user.\n\nHowever, with the rise of mobile Internet, the drawbacks of this traditional fingerprint authentication system were exposed. First is security issue, the user fingerprint data stored directly in the system computer, user’s fingerprint image information is easy to be stolen; Second is usability and cost issues, the traditional fingerprint system requires sensor to input users’ fingerprints and the system deployment requires a separate terminal hardware and terminal software. All these lead to increased costs and decreased usability. Third is a scalability issue, the architecture of host-database is not easy to extend. Once scenarios need to use the system, we must purchase the corresponding hardware and software, leading to poor scalability.\n\nIn this paper, the drawbacks of traditional fingerprint identification system has been improved and reorganized. We developed a web-based fingerprint authentication system using smartphone, and used a number of security defense strategies to enhance the security of the system. Finally, the new approach can solve the security, usability, cost and scalability issues in the traditional fingerprint identification system.\nSystem architecture is as follows:\n![figure 2](/images/2.png)\nThe innovation of the system is:\n1. Using smartphone camera instead of the traditional fingerprint sensor, to solve the cost and usability issues.\n2. Using Web Service to provide cross-platform service to solve the cost and scalability issues.\n3. Using enhanced security defense strategy, to solve the security issue.\n\nThis paper focuses on the server solution based on enhanced security strategy.\n\n## 1.2 Security Threat and Defense Strategy\nThe following security threat will occur in the web-based fingerprint authentication system:\n### 1.2.1 Intercept Information\nThe purpose of intercepting information is to steal data content itself. This type of security threat is commonly referred to as data security threats. In the fingerprint authentication system, client needs to send the fingerprint image file to the server through network. During transmission, once the system is attacked, it may cause the fingerprint image data to be intercepted, and then the user information will be stolen.\n![figure 3](/images/thesis/chapter1/1.bmp)\n### 1.2.2 Replay attack\nDestroying the validity of certification is a basic form of authentication attack. A replay attack is a form of network attack in which a valid data transmission is maliciously or fraudulently repeated or delayed. This is carried out either by the originator or by an adversary who intercepts the data and retransmits it, possibly as part of a masquerade attack by IP packet substitution.\n\nThe classic example of replay attack is as follows:\n![figure 4](/images/thesis/chapter1/2.bmp)\nSuppose Alice wants to prove her identity to Bob. Bob requests her password as proof of identity, which Alice dutifully provides (possibly after some transformation like a hash function); meanwhile, Eve is eavesdropping on the conversation and keeps the password (or the hash). After the interchange is over, Eve (posing as Alice) connects to Bob; when asked for a proof of identity, Eve sends Alice’s password (or hash) read from the last session, which Bob accepts thus granting access to Eve.\n![figure 5](/images/thesis/chapter1/3.bmp)\n### 1.2.3 Data Modification\nThis type of network attacks is an extension of replay attack. Attackers using replay attack damage the system certification to enter the system. Then they can send the forged data to the server easily. And even they will do SQL injection attacks or modify server information. The basic model is as follows:\n![figure 6](/images/thesis/chapter1/4.bmp)\n\n## 1.3 Fingerprint Certification System with Enhanced Security\n### 1.3.1 Image Encryption\nFor attacks in 1.2.1, the usual defense strategy is image encryption. Before the client sends the image file, we can use a specific algorithm to encrypt image. Then client sends the file to the server. After the server receives the file, we will use the same algorithm to decrypt the image. In this case, even if attackers intercept the image file, he still cannot get the real information, thus preventing information leakage.\n![figure 7](/images/thesis/chapter1/5.bmp)\n### 1.3.2 Timestamp Authentication\nIt is efficient defense against replay attack to add timestamp to the system. To use this approach, we should ensure synchronization between client and server. First, the server generates a dynamic password from time to time. Second, the client sends a request to get the dynamic password. Finally, client sends username and dynamic password to login system. In this case, even if the middle man steal the password, it is only effective in a very short time.\n![figure 8](/images/thesis/chapter1/6.bmp)\n### 1.3.3 Challenge-Response Authentication\nChallenge-Response Authentication is another effective method to prevent replay attack. The basic model is as follows:\n1. Client sends a request to login. (We can assume it is ‘GET’ request)\n2. Server generates a random number K=random (NUM), then return K to Client. Besides, server should save K to the session.\n3. Client calculates R=Hmac(K, P), then sends the result to the server. In the formula, K represents key (the random number), P represents user password, Hmac() is a Hash Function.\n4. Server gets the user password from database and does the same calculation R’=hmac() as step 3. Then comparing R’ with R, if R’ equals R, users will login system successfully.\n\nIn this process, the man in the middle can only get K and R, but K is a random number while R is a hash result, the two numbers are both meaningless. Attackers cannot get user password through the two numbers. System security is improved.\n![figure 9](/images/thesis/chapter1/7.bmp)\n\n## 1.4 Fingerprint Authentication System with Enhanced Security\nThe paper discusses a fingerprint authentication system with enhanced security. First, we will use the new approach to instead of the traditional approach, we will not use fingerprint sensor to get user fingerprint data. Instead, we use smartphone camera to get the user information. It will be more convenient and low cost. Second, we use Web Service to provide web-based authentication service with enhanced security. We use some methods to improve the system security and prevent network attack. Finally, we will realize a new fingerprint authentication system with convenience, security and low cost.\n\nThe paper will be divided into 7 chapters.\nChapter 1 expresses the problems of the existed fingerprints authentication system and gives a new approach to solve the problems.\nChapter 2 introduces the related work of fingerprints system and system security.\nChapter 3 gives the system architecture to show how it works.\nChapter 4 discusses the security strategy to prevent network attack.\nChapter 5 discusses fingerprints matcher web service.\nChapter 6 talks about match results.\nChapter 7 gives the conclusion.\n\n# 2 Related work\nThis part will give some current research. Because our research is comprehensive research. This parts will contain three or more kinds of research.\n* The research about Fingerprint Recognition System.\n* The research about reversible watermark.\n* The research about replay attack and security.\n* The research about system architecture and REST web service.\n* The research about barcode.\n\n# 3 Proposal Solution\nThis part ([4.1](http://lichcnpul.github.io/2015/06/24/4Security-Strategy/) and [Algorithm](http://lichcnpul.github.io/2015/06/25/Algorithm/)) have been written. However, I am doing some systemative tests, so it will be modified later.\nThis chapter discuss the security strategy in the fingerprint authentication system. First, we will talk about security threat briefly; Second, we discuss the traditional approach to enhance security; Third, we give a fingerprint watermark approach to solve the security problems. We will discuss reversible watermarking technology in this part.\n## 3.1 Common Solution\n### 3.1.1 Security Threat\nAs we have talked in chapter 1, there are some types of internet attack. One is to **intercept information**. The purpose of intercepting information is to steal data content itself. Another one is to **replay attack**. Replay attack is a form of network attack in which a valid data transmission is maliciously or fraudulently repeated or delayed. In our system, attackers will try to intercept user’s packages which contain fingerprint images. This is a kind of intercept attack. In this case, user information will be leaked. In addition, the attackers intercept data packages then they can resend these data packages to the server regardless of whether the data is encrypted. This is a kind of replay attack. Attackers use replay attack to realize the purpose of spoofing server. Then the server will consider the attacker to be the original user.\n\nThe fingerprint authentication system should be security. We try to design some security subsystem to enhance the system security. Then the system should be prevent information interception and replay attack.\n### 3.1.2 Common Solution\nFile encryption and digital signature is a common approach to enhance system security.\n* File encryption : Prevent information leaks.\n* Digital signature : Ensure the message sent by the original sender.\n\nFile encryption： The basic process flow of file encryption is to encode the original file by an algorithm, making it unreadable(commonly referred to as “ciphertext”). The original file cannot be displayed without **key**. By this way we can prevent data from being illegally stolen. The reverse process is called decryption. such as: [Algorithm 1](http://blog.csdn.net/stpeace/article/details/8315772) and [Algorithm 2](http://wenku.baidu.com/link?url=Szecji7gvHr35DDq2ltqNqa4aYdajxnfNinz8WA3_4WWVXKHgj6IFUvjTgY_V-w9eqcz4YppASDBfejSm0cIMGMZA62YlXNME9e2ZfxwVoK)\n\nDigital signature: A digital signature is a mathematical technique used to validate the authenticity and integrity of a message, software or digital document. see [searchsecurity](http://searchsecurity.techtarget.com/definition/digital-signature). The basic flow of digital signature is like this:\n![figure 1](/images/thesis/1.png)\nFrom this diagram, we can know how digital-signature works. First, the data sender uses his private key to encode the information he prepared to send, then he gets a signed message. Second, he send the signed message to the receiver. The receiver gets the signed message and decodes the message by the sender’s public key. Then the receiver gets the decrypted hash. If the decrypted hash matches a second computed hash of the same data, it proves that the data hasn’t changed since it was signed. Otherwise, it proves that the data has been changed by attackers since it was signed.\n### 3.1.3 Disadvantages\nThe traditional approach is good enough to enhance system security and prevent internet attack. However, there are still some disadvantages to apply it to our fingerprint system.\n1. **Complex**. Digital-signature need to be controlled in a complex architecture. Besides, we need to build two separate subsystems, one is for file encryption, the other one is for digital signature. It will be more complex.\n2. **Common Approach**. It is a common approach to enhance system security. It does not take into account the characteristics of the fingerprint image.\n\n## 3.2 New Solution\nIn order to overcome the two drawbacks, we try to propose a new approach. The new approach is a kind of reversible digital watermark technology and it combine file encryption with authentication.\n### 3.2.1 Problems\nIf we do not use the technology of File encryption and Digital signature, let's see the security holes in our system first.\n![case 1](/images/thesis/chapter3/7.bmp)\nIn this case, User A wants to use this system to authentication, he use his smartphone to take his fingerprint picture, then A sends this picture to the server for matching directly. However, the attacker B was listening to this communication, he is a bad guy and intercepts user A's fingerprint image. As you can see in this figure, B get the A's personal information. After few minutes, the attacker B was posing A to send the fingerprint image to the server. Thus the system will take B as A, the attacker B will obtain system authentication. Now user A is unsafe, because B gets the same system authority as A. Our system cannot prevent interception and replay attack, we should improve the system with some security arrangement.\n### 3.2.2 Improvement 1\nTo enhance security of the system, we import the security module.\n1. To prevent information leaks, the client should not send the original fingerprint picture to the server.\n2. To prevent replay attack, the system can use a technology called one-time pad. It means that the key is valid only once. To achieve one-time pad system, we can take timestamp as a key. When user wants to authenticate the fingerprint, server-side checks the timestamp first, if the timestamp key is right, then the system do the matching. Otherwise, the system will not match the fingerprint with database.\n\nIn order to achieve the above two points, we combine barcode technology with our fingerprint system. First, server-side takes timestamp to encode a barcode picture and sends it to client. In this way, the barcode picture contains the timestamp information, it can be as a one-time key to prevent replay attack. Besides, we can combine the barcode picture with original fingerprint picture, then the client will use a new picture to instead of the original fingerprint picture. Finally, bar code technology meets the requirements of the above two aspects.\n![case 2](/images/thesis/chapter3/8.bmp)\nIn this case, user A take photos first, then he sends the request to server. The server takes current timestamp to generate a barcode picture and sends it back to client. After client receives the barcode picture, it sets the original fingerprint picture to the center of the barcode picture. Then the new picture will be send to the server. The server receives the new picture and decodes the barcode to check whether timestamp is correct. If it is the same as server-side timestamp, the system will send the picture to matching module. Otherwise, the server will return fail information to client.\n\nNow let's analyse security things of new system. The attacker B can still steal the picture which combines barcode with fingerprint image. But he cannot get the original fingerprint picture directly. What's more, he cannot do replay attack any longer. If he resends the picture which he intercepted, the timestamp of that picture is already useless because the timestamp of server-side is used before. So the server will not send the picture to matching module, it will return fail information to the attacker.\n\nThe security of our system has been improved. However, it's still not safe enough. The attackers have some methods to get the original fingerprint picture easily. They can cut down the center of the picture then they will get the original fingerprint picture, it is not hard. After they get the original fingerprint picture, they can send request to server to get a new qrcode picture. Then they can encode qrcode with original fingerprint image, it is a kind of replay attack. In this way, the timestamp is new and useful. The attackers will obtain system authentication successfully. So it is necessary to improve this solution to prevent this kind of phenomenon.\n### 3.2.3 Improvement 2\nThe basic idea will be not changed. The problem of the solution described above is that it just combines fingerprint picture with barcode picture directly. The fingerprint image is not hidden and is easy to reverse. So if we can use an algorithm to hide the fingerprint image, it will be hard to reverse. Then the system will be safer.\n\nA technology called reversible digital watermark will be applied in our system. Using this technology, we could combine fingerprint image with barcode image easily and the fingerprint image will be hidden at the same time. The fingerprint picture will be as watermark and it will not be sended to the server directly.  \n![case 3](/images/thesis/chapter3/9.bmp)\nThe solution is similar to the solution described in 3.2.2, we just use watermark technology in this solution. The client takes fingerprint picture as watermark and encodes it into the barcode picture. We will discuss algorithm in chapter 5. After encoding, the client sends the new picture to the server. The server-side receives the picture and calls decoding module to decode picture. After decoding, the server will separate fingerprint image from barcode picture. Then the system will check the timestamp and do the matching things.\n\nNow the system is safer than before. The attackers will not get the original fingerprint picture easily. They can only get qrcode picture while that picture is not useful for authentication. If attackers attempt to recover the original fingerprint picture, they must know the algorithm first. Howerver, if the attackers get the algorithm of encoding, the system is still unsafe. So we have to improve the system more.\n### 3.2.4 Improvement 3\nFinally, we add a key to the system.\n![case 4](/images/thesis/chapter3/10.bmp)\nIn this way, the attackers must get both key and algorithm to recover the original fingerprint picture. The cost is very high. So we think the system is safe enough.\n\n# 4 System Architecture\nChinese Version: [Chapter 3](http://lichcnpul.github.io/2015/06/26/3System-Architecture/) and [3.2 Nancy Framework](http://lichcnpul.github.io/2015/06/29/Nancy-Framework/)\nThis chapter will introduce system flow and the choice of architecture. This part will be divided to two parts. Part One introduces the specification of the hole system; Part Two discusses system framework and how it works.\n## 4.1 Basic Business Process\n### 4.1.1 Business Component\nBusiness component contains four parts:\n1. **Client**: smart phone(Android), fingerprint image acquisition module, feature extraction module, encryption module;\n\n2. **Server**: Web Sever，decryption module, authentication module, fingerprint matching module;\n\n3. **Third-party components**: Fingerprint Matcher SDK;\n\n4. **Database**: fingerprint image database, user database.\n\n### 4.1.2 Business Flow\nThe basic flow of the system is shown below:\n![basic flow](/images/thesis/chapter3/1.bmp)\nBusiness process consists of the following processes:\n1. **Fingerprint Image Acquisition**: User login android client, then the client calls camera and image acquisition module to get user fingerprint image.\n\n2. **Image Preprocessing and Feature Extraction**: The client calls feature extraction module to preprocess the fingerprint image and extract the feature of user's fingerprint.\n\n3. **Image Encryption**: First the client receives the QR Code information from server, then it calls encryption module to encode fingerprint image with QR Code information.\n\n4. **Image Upload**: The client calls Web API to upload the encrypted fingerprint images to the server.\n\n5. **Image Decryption**: The server calls decryption module to decode the encrypted fingerprint image, then it will get original fingerprint image and QR Code information.\n\n6. **User Authentication**: The server calls authentication module to check the QR Code information and ensure the authenticity of the user.\n\n7. **Fingerprint Matching**: The server calls Fingerprint Matcher SDK to compare user-uploaded fingerprint image with the fingerprint database, then it will get the matching score.\n\n8. **Result Display**: The server sends the matching score back to the client. Then the client determines whether the user is authenticated by matching score.\n\n## 4.2 SOA and Web Service\n### 4.2.1 SOA\nSOA is service-oriented architecture. Simple, SOA is a kind of new architecture to develop application system. In the system based on SOA architecture, functionality of the application is a combination of the components together. These components are loosely coupled and have a unified interface definitions, we often called the components as service. The advantages of SOA architecture is to achieve cross-platform and scalability of application system.\n\nFor example, in our fingerprint authentication system, now we need achieve an Android client and a server-side. Android client communicates with server-side and calls the API provided by server to achieve the functions of fingerprint upload and fingerprint authentication. In the traditional software architecture, the client and server development should be in the same technical architecture, for example, if the client uses Android technology, the server should also use Java EE technology; if the client uses Windows Phone technology, the server should also use .net framework. The software architecture model is a tightly coupled architecture. The advantage of this model is close cooperation, and the client and server both call the same underlying module. However, the disadvantage of this model is bad scalability. If you use .net technology to develop client side, the server-side has to use the same technology. This kind of architecture is not suitable for the development of mobile internet.\n\nIn the mobile Internet era, a service often provides support for a variety of clients. For example, social software \"Line\" has some service for clients. The login service needs provide support for PC clients, it also needs provide support for Android clients and iOS clients, even it need provide the service for browser. If we use traditional system architecture, we have to write service code for every platform. However, the service code is almost the same. It does not conform the software engineering principle of DRY(Don‘t Repeat Yourself). In this background, SOA architecture have been developed rapidly.\n\nIn SOA architecture each application functions will be packaged as service, while these services are platform-independent. Client communicates with server by message delivery. When the client needs call server API, it can send a message to the server interface, thus achieving the transformation of architecture from specific technology-oriented to service-oriented. Whether the client uses Android technology, or iOS technology, or web technology, or desktop technology, it can call the same service while it is not necessary to change any code in server-side. The SOA architecture model greatly enhanced cross-platform and scalability of application system, now SOA has became mainstream architecture model in mobile Internet era. Web Service is a kind of technology to achieve SOA.\n![SOA](/images/thesis/chapter3/2.bmp)\n### 4.2.2 Web Service\nWeb Service is one of the most commonly used techniques to achieve SOA. It provides services through a standard web protocol, the purpose of Web service is to ensure that different applications can interoperate.（[Web Service](https://en.wikipedia.org/wiki/Web_service)）\n\nAfter years of development, there are two main types of web service currently .\n1. SOAP-based Web Service\n2. REST-based Web Service\n\nSOAP-based Web Service: SOAP is used to describe the format of the information transmitted, WSDL is used to describe how to access specific interface, UDDI is used to manage, distribute, query Web Service. SOAP uses two protocols have been widely used: HTTP and XML(a subset of Standard Generalized Markup Language). HTTP is used to implement RPC-style SOAP transmissions, and XML is its encoding format. By using SOAP, Web Service has a good scalability, completely independent of the vendor, programming language and platform.\n\nREST-based Web Service: Dr. RT Fielding's doctoral dissertation \"Architectural Styles and the Design of Network-based Software Architectures\" laid the basis for REST-style Web Service. REST is Representational State Transfer. It has the following characteristics:\n1. First REST is a style, not a standard.\n2. REST is based on resource.\n3. The purpose of REST is to decide how to make a well defined web application forward.\n4. REST makes full use of HTTP　protocol.\n* It locates resources by logic URI.\n* It distinguishes what format of data the client wants to get by HTTP Request Header Information.\n* In REST architecture, the CRUD(create,read,update and delete) operation is handled by using different HTTP request methods.\n\n![REST API](/images/thesis/chapter3/3.bmp)\nThe characteristics of REST style make it more lightweight than SOAP, fuller use HTTP protocol. REST really expresses the original intention of HTTP protocol. REST has completely changed the status of Web Service, adapted to the trend of mobile internet, and now the mainstream mobile client development has shifted to the REST style Web Service. In order to achieve the Android client of fingerprint verification, we also use REST style Web Service in our system.\n## 4.3 Nancy Framework  \nWe use Nancy Framework to achieve a lightweight REST-style Web Service. Nancy Framework is a lightweight web framework based on .Net and mono platforms, it follows the MVC model and is designed to provide REST-style Web Service. On its [official website](http://nancyfx.org/) , it introduces the following features of Nancy:\n1. Nancy is a lightweight, low-ceremony, framework for building HTTP based services on .Net and Mono. The goal of the framework is to stay out of the way as much as possible and provide a super-duper-happy-path to all interactions.\n2. Nancy is designed to handle DELETE, GET, HEAD, OPTIONS, POST, PUT and PATCH requests and provides a simple, elegant, Domain Specific Language (DSL) for returning a response with just a couple of keystrokes.\n3. Nancy is built to run anywhere.\n\n### 4.3.1 MVC\nThe design ideas of Nancy Framework comes from Ruby's Sinatra Framework, whose basic idea is MVC model. MVC model is Model-View-Controller mode.\n* Model is a part of application system to deal with data logic, typically used to encapsulate data objects to store data.\n* View is a part of application system to display data to user. View data usually need to be obtained from model.\n* Controller is responsible for reading data from the view, controlling user input, and sending data to the model.\n\n![MVC](/images/thesis/chapter3/4.bmp)\nThe figure shows the basic principle of MVC model:\n1. First, user sends a request to the application, waiting for the server to respond.\n2. Controller receives the user request, then it decides which model or view to respond according to the header of request.\n3. Controller sends data requests to model.\n4. Model gets data from database and returns the data to controller\n5. controller sends the acquired data to the corresponding view.\n6. Fill view according to the model data, and return the results to the controller.\n7. Controller returns view to user.\n\nThrough MVC model, the separation of application business logic and performance is realized. It also reduces the coupling between modules. Now more and more application systems are using MVC model, many frameworks also follow the MVC model, such as Ruby on Rails, Java Spring MVC, ASP.net MVC etc.. The Nancy Framework which we used is also a super lightweight MVC framework on .net platform.\n### 4.3.2 Nancy Framework\nNancy Framework is a super lightweight web framework on .net platform based on MVC mode. The structure of Nancy project is shown below:\n![Nancy](/images/thesis/chapter3/5.png)\nIn Nancy Framework, Model is M, Views is V, Module is C.\n1. Controller uses rest style, the basic mode is as follows: when user inputs uri http://hostaddress/ in the browser, the controller class of Nancy framework will match the corresponding controller based on uri firstly. This mechanism is called Route mechanism, it is the core of Nancy Framework to achieve REST-style controller. When a user requests the resources on root directory in 'GET' method, the controller will find the GET[\"/\"] controller based on Route mechanism. After the match is successful, the user request is processed by the controller. The controller can call the corresponding view resources and model resources in response to user requests.\n``` csharp\nGet[\"/\"] = parameters =>\n{\n    return View[\"index\"];\n};\n```\n2. View takes HTML as the basic style, the official supported view engine is Radar engine, the syntax of Radar is similar to HTML.\n``` html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Fingerprint Web Service Page</title>\n</head>\n<body>\n    Content\n</body>\n</html>\n```\n3. Model generally takes Database as objects and supports most of the ORM framework.\n\n## 4.4 System Architecture Diagram\nThe architecture diagram of the fingerprint identification system is as follows:\n![System Architecture](/images/thesis/chapter3/6.bmp)\n\n# 5 Algorithm\n## 5.1 Display Matrix\nSuppose the QR Code image matrix is：\n\n$Q=\\begin{bmatrix}\n255 & 254 & 255 & 1 & 2 & \\cdots\\\\\\\n255 & 255 & 255 & 1 & 1 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nIts binary form is：\n\n$Q=\\begin{bmatrix}\n111111\\color{red}{11} & 111111\\color{red}{10} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{10} & \\cdots\\\\\\\n111111\\color{red}{11} & 111111\\color{red}{11} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{01} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nThe watermark image matrix is:\n\n$M=\\begin{bmatrix}\n167 & 63 & 15 & \\cdots\\\\\\\n255 & 127 & 128 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nIts binary form is:\n\n$M=\\begin{bmatrix}\n10100111 & 00111111 & 00001111 & \\cdots\\\\\\\n11111111 & 01111111 & 10000000 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nNow we will separate the watermark matrix to encode it to the QRcode matrix.\nLet's focus the watermark matrix first.\n## 5.2 Watermark Matrix\nFor the watermark matrix above, we called it M, we can see M(1,1)=167, in binary form, M(1,1)=10100111. We separate it to 4 parts.\n\n<strong><font color=\"red\" size=\"6\">10</font></strong><strong><font color=\"green\" size=\"6\">10</font></strong><strong><font color=\"blue\" size=\"6\">01</font></strong><strong><font color=\"yellow\" size=\"6\">11</font></strong>\n\n1. The Red Part: the 1-2 bit\n2. The Green Part: the 3-4 bit\n3. The Blue Part: the 5-6 bit\n4. The Yellow Part: the 7-8 bit\n\nThen we can get 4 matrix from 4 parts:\n1.The Red Part Matrix is:\n\n$M1=\\begin{bmatrix}\n10 & 00 & 00 & \\cdots\\\\\\\n11 & 01 & 10 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 0 & 0 & \\cdots\\\\\\\n3 & 1 & 2 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n2.The Green Part Matrix is:\n\n$M2=\\begin{bmatrix}\n10 & 11 & 00 & \\cdots\\\\\\\n11 & 11 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 3 & 0 & \\cdots\\\\\\\n3 & 3 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n3.The Blue Part Matrix is:\n\n$M3=\\begin{bmatrix}\n01 & 11 & 11 & \\cdots\\\\\\\n11 & 01 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n1 & 3 & 3 & \\cdots\\\\\\\n3 & 1 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n4.The Yellow Part Matrix is:\n\n$M4=\\begin{bmatrix}\n11 & 11 & 11 & \\cdots\\\\\\\n11 & 11 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n3 & 3 & 3 & \\cdots\\\\\\\n3 & 3 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n## 5.3 Encoding Method\n### 5.3.1 Why we can encode QRCode Image with watermark image?\nThe QRCode Image is bigger than watermark image. The rows of QRCode image is 3 times higher than watermark image; the colmns is 5 times higher than watermark image. So we can embed the watermark matrix into qrcode matrix. It is very important. In our method, the watermark matrix M is a 392\\*357 matrix; the qrcode matrix Q is a 900\\*5000 matrix.\n\nIn addition, the QRCode image and watermark image are both grayscale images.\n### 5.3.2 How to encode?\nWe use Least Significant Bit Algorithm. First, we separate matrix Q to 5 parts.\n\n$Q=\\begin{bmatrix}\nA&B& \\\\\\\nC&D& \\\\\\\n & &E\n\\end{bmatrix}$\n\nFor matrix A,B,C,D, they are all 392\\*357 matrix. E is the rest part of Q.\nThen we use A,B,C,D and M1,M2,M3,M4 to encode. We set the least 2 bits of A,B,C,D to 0. For example:\n\n$A=\\begin{bmatrix}\n111111\\color{red}{11} & 111111\\color{red}{10} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{10} & \\cdots\\\\\\\n111111\\color{red}{11} & 111111\\color{red}{11} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{01} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nset the least 2 bits to 0:\n\n$A1=\\begin{bmatrix}\n111111\\color{red}{00} & 111111\\color{red}{00} & 111111\\color{red}{00} & 000000\\color{red}{00} & 000000\\color{red}{00} & \\cdots\\\\\\\n111111\\color{red}{00} & 111111\\color{red}{00} & 111111\\color{red}{00} & 000000\\color{red}{00} & 000000\\color{red}{00} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nthen we use matrix M1 instead of the least 2 bits of A:\n```python\nA2 = A1 + M1\n```\nFor B,C,D and M2,M3,M4 ,we do the some operation:\n```python\nB2 = B1 + M2\nC2 = C1 + M3\nD2 = D1 + M4\n```\nAfter that, we will get a new matrix called Q2:\n\n$Q2=\\begin{bmatrix}\nA2&B2& \\\\\\\nC2&D2& \\\\\\\n & &E\n\\end{bmatrix}$\n\nThe matrix Q2 contains all the information of watermark images. Now we have realized Encoding Module.\n\n## 5.4 Decoding Method\nIt is easy to get the watermark matrix. From Q2 we can extract A2,B2,C2,D2, then we will get M1,M2,M3,M4 by mod([A2,B2,C2,D2],4).\n```python\nM1(i,j) = A2(i,j) mod 4\nM2(i,j) = B2(i,j) mod 4\nM3(i,j) = C2(i,j) mod 4\nM4(i,j) = D2(i,j) mod 4\n```\nFrom M1, M2, M3, M4, we will recover watermark matrix easily.\n```python\nM(i,j)=M4(i,j)＋4 * M3(i,j)＋16 * M2(i,j)＋64 * M1(i,j)\n```\nIn this way, now we have already recover the watermark matrix.\n# 6 Fingerprint Matching\n## 6.1 Basic concept\n## 6.2 Exist Tools\n## 6.3 SourceAFIS\n# 7 Communication and Results\n# 8 Conclusion\n# Reference\n","source":"_posts/150703-thesis.md","raw":"title: thesis\ndate: 2015-07-03 16:48:53\ncategories: Thesis (English Verion)\ntags: thesis\ntoc: true\n---\n# 1 Introduction\nThis part has been done.However, It need some modification later. [Chapter 1](http://lichcnpul.github.io/2015/06/22/1Introduction/)\n## 1.1 Fingerprint Certification System\nFingerprint identification system is an important identity authentication system. It will be more and more important in modern society. Traditional fields such as security system, access control system must use this technology. With the rise of the mobile Internet, more and more emerging fields such as e-commerce, electronic payment also need this technology.\n\nThe traditional fingerprint recognition system adopts the following technical architecture:\n![figure 1](/images/1.png)\nThe business process is as follows:\n1. Users press the fingerprints on the fingerprints sensor.\n2. The sensor is connected to the computer system and sends the user’s fingerprints directly to the computer system.\n3. The similarity of fingerprint data between user and database will be compared.\n4. The fingerprint authentication system judges whether the user is authenticated by the similarity and returns the result to the user.\n\nHowever, with the rise of mobile Internet, the drawbacks of this traditional fingerprint authentication system were exposed. First is security issue, the user fingerprint data stored directly in the system computer, user’s fingerprint image information is easy to be stolen; Second is usability and cost issues, the traditional fingerprint system requires sensor to input users’ fingerprints and the system deployment requires a separate terminal hardware and terminal software. All these lead to increased costs and decreased usability. Third is a scalability issue, the architecture of host-database is not easy to extend. Once scenarios need to use the system, we must purchase the corresponding hardware and software, leading to poor scalability.\n\nIn this paper, the drawbacks of traditional fingerprint identification system has been improved and reorganized. We developed a web-based fingerprint authentication system using smartphone, and used a number of security defense strategies to enhance the security of the system. Finally, the new approach can solve the security, usability, cost and scalability issues in the traditional fingerprint identification system.\nSystem architecture is as follows:\n![figure 2](/images/2.png)\nThe innovation of the system is:\n1. Using smartphone camera instead of the traditional fingerprint sensor, to solve the cost and usability issues.\n2. Using Web Service to provide cross-platform service to solve the cost and scalability issues.\n3. Using enhanced security defense strategy, to solve the security issue.\n\nThis paper focuses on the server solution based on enhanced security strategy.\n\n## 1.2 Security Threat and Defense Strategy\nThe following security threat will occur in the web-based fingerprint authentication system:\n### 1.2.1 Intercept Information\nThe purpose of intercepting information is to steal data content itself. This type of security threat is commonly referred to as data security threats. In the fingerprint authentication system, client needs to send the fingerprint image file to the server through network. During transmission, once the system is attacked, it may cause the fingerprint image data to be intercepted, and then the user information will be stolen.\n![figure 3](/images/thesis/chapter1/1.bmp)\n### 1.2.2 Replay attack\nDestroying the validity of certification is a basic form of authentication attack. A replay attack is a form of network attack in which a valid data transmission is maliciously or fraudulently repeated or delayed. This is carried out either by the originator or by an adversary who intercepts the data and retransmits it, possibly as part of a masquerade attack by IP packet substitution.\n\nThe classic example of replay attack is as follows:\n![figure 4](/images/thesis/chapter1/2.bmp)\nSuppose Alice wants to prove her identity to Bob. Bob requests her password as proof of identity, which Alice dutifully provides (possibly after some transformation like a hash function); meanwhile, Eve is eavesdropping on the conversation and keeps the password (or the hash). After the interchange is over, Eve (posing as Alice) connects to Bob; when asked for a proof of identity, Eve sends Alice’s password (or hash) read from the last session, which Bob accepts thus granting access to Eve.\n![figure 5](/images/thesis/chapter1/3.bmp)\n### 1.2.3 Data Modification\nThis type of network attacks is an extension of replay attack. Attackers using replay attack damage the system certification to enter the system. Then they can send the forged data to the server easily. And even they will do SQL injection attacks or modify server information. The basic model is as follows:\n![figure 6](/images/thesis/chapter1/4.bmp)\n\n## 1.3 Fingerprint Certification System with Enhanced Security\n### 1.3.1 Image Encryption\nFor attacks in 1.2.1, the usual defense strategy is image encryption. Before the client sends the image file, we can use a specific algorithm to encrypt image. Then client sends the file to the server. After the server receives the file, we will use the same algorithm to decrypt the image. In this case, even if attackers intercept the image file, he still cannot get the real information, thus preventing information leakage.\n![figure 7](/images/thesis/chapter1/5.bmp)\n### 1.3.2 Timestamp Authentication\nIt is efficient defense against replay attack to add timestamp to the system. To use this approach, we should ensure synchronization between client and server. First, the server generates a dynamic password from time to time. Second, the client sends a request to get the dynamic password. Finally, client sends username and dynamic password to login system. In this case, even if the middle man steal the password, it is only effective in a very short time.\n![figure 8](/images/thesis/chapter1/6.bmp)\n### 1.3.3 Challenge-Response Authentication\nChallenge-Response Authentication is another effective method to prevent replay attack. The basic model is as follows:\n1. Client sends a request to login. (We can assume it is ‘GET’ request)\n2. Server generates a random number K=random (NUM), then return K to Client. Besides, server should save K to the session.\n3. Client calculates R=Hmac(K, P), then sends the result to the server. In the formula, K represents key (the random number), P represents user password, Hmac() is a Hash Function.\n4. Server gets the user password from database and does the same calculation R’=hmac() as step 3. Then comparing R’ with R, if R’ equals R, users will login system successfully.\n\nIn this process, the man in the middle can only get K and R, but K is a random number while R is a hash result, the two numbers are both meaningless. Attackers cannot get user password through the two numbers. System security is improved.\n![figure 9](/images/thesis/chapter1/7.bmp)\n\n## 1.4 Fingerprint Authentication System with Enhanced Security\nThe paper discusses a fingerprint authentication system with enhanced security. First, we will use the new approach to instead of the traditional approach, we will not use fingerprint sensor to get user fingerprint data. Instead, we use smartphone camera to get the user information. It will be more convenient and low cost. Second, we use Web Service to provide web-based authentication service with enhanced security. We use some methods to improve the system security and prevent network attack. Finally, we will realize a new fingerprint authentication system with convenience, security and low cost.\n\nThe paper will be divided into 7 chapters.\nChapter 1 expresses the problems of the existed fingerprints authentication system and gives a new approach to solve the problems.\nChapter 2 introduces the related work of fingerprints system and system security.\nChapter 3 gives the system architecture to show how it works.\nChapter 4 discusses the security strategy to prevent network attack.\nChapter 5 discusses fingerprints matcher web service.\nChapter 6 talks about match results.\nChapter 7 gives the conclusion.\n\n# 2 Related work\nThis part will give some current research. Because our research is comprehensive research. This parts will contain three or more kinds of research.\n* The research about Fingerprint Recognition System.\n* The research about reversible watermark.\n* The research about replay attack and security.\n* The research about system architecture and REST web service.\n* The research about barcode.\n\n# 3 Proposal Solution\nThis part ([4.1](http://lichcnpul.github.io/2015/06/24/4Security-Strategy/) and [Algorithm](http://lichcnpul.github.io/2015/06/25/Algorithm/)) have been written. However, I am doing some systemative tests, so it will be modified later.\nThis chapter discuss the security strategy in the fingerprint authentication system. First, we will talk about security threat briefly; Second, we discuss the traditional approach to enhance security; Third, we give a fingerprint watermark approach to solve the security problems. We will discuss reversible watermarking technology in this part.\n## 3.1 Common Solution\n### 3.1.1 Security Threat\nAs we have talked in chapter 1, there are some types of internet attack. One is to **intercept information**. The purpose of intercepting information is to steal data content itself. Another one is to **replay attack**. Replay attack is a form of network attack in which a valid data transmission is maliciously or fraudulently repeated or delayed. In our system, attackers will try to intercept user’s packages which contain fingerprint images. This is a kind of intercept attack. In this case, user information will be leaked. In addition, the attackers intercept data packages then they can resend these data packages to the server regardless of whether the data is encrypted. This is a kind of replay attack. Attackers use replay attack to realize the purpose of spoofing server. Then the server will consider the attacker to be the original user.\n\nThe fingerprint authentication system should be security. We try to design some security subsystem to enhance the system security. Then the system should be prevent information interception and replay attack.\n### 3.1.2 Common Solution\nFile encryption and digital signature is a common approach to enhance system security.\n* File encryption : Prevent information leaks.\n* Digital signature : Ensure the message sent by the original sender.\n\nFile encryption： The basic process flow of file encryption is to encode the original file by an algorithm, making it unreadable(commonly referred to as “ciphertext”). The original file cannot be displayed without **key**. By this way we can prevent data from being illegally stolen. The reverse process is called decryption. such as: [Algorithm 1](http://blog.csdn.net/stpeace/article/details/8315772) and [Algorithm 2](http://wenku.baidu.com/link?url=Szecji7gvHr35DDq2ltqNqa4aYdajxnfNinz8WA3_4WWVXKHgj6IFUvjTgY_V-w9eqcz4YppASDBfejSm0cIMGMZA62YlXNME9e2ZfxwVoK)\n\nDigital signature: A digital signature is a mathematical technique used to validate the authenticity and integrity of a message, software or digital document. see [searchsecurity](http://searchsecurity.techtarget.com/definition/digital-signature). The basic flow of digital signature is like this:\n![figure 1](/images/thesis/1.png)\nFrom this diagram, we can know how digital-signature works. First, the data sender uses his private key to encode the information he prepared to send, then he gets a signed message. Second, he send the signed message to the receiver. The receiver gets the signed message and decodes the message by the sender’s public key. Then the receiver gets the decrypted hash. If the decrypted hash matches a second computed hash of the same data, it proves that the data hasn’t changed since it was signed. Otherwise, it proves that the data has been changed by attackers since it was signed.\n### 3.1.3 Disadvantages\nThe traditional approach is good enough to enhance system security and prevent internet attack. However, there are still some disadvantages to apply it to our fingerprint system.\n1. **Complex**. Digital-signature need to be controlled in a complex architecture. Besides, we need to build two separate subsystems, one is for file encryption, the other one is for digital signature. It will be more complex.\n2. **Common Approach**. It is a common approach to enhance system security. It does not take into account the characteristics of the fingerprint image.\n\n## 3.2 New Solution\nIn order to overcome the two drawbacks, we try to propose a new approach. The new approach is a kind of reversible digital watermark technology and it combine file encryption with authentication.\n### 3.2.1 Problems\nIf we do not use the technology of File encryption and Digital signature, let's see the security holes in our system first.\n![case 1](/images/thesis/chapter3/7.bmp)\nIn this case, User A wants to use this system to authentication, he use his smartphone to take his fingerprint picture, then A sends this picture to the server for matching directly. However, the attacker B was listening to this communication, he is a bad guy and intercepts user A's fingerprint image. As you can see in this figure, B get the A's personal information. After few minutes, the attacker B was posing A to send the fingerprint image to the server. Thus the system will take B as A, the attacker B will obtain system authentication. Now user A is unsafe, because B gets the same system authority as A. Our system cannot prevent interception and replay attack, we should improve the system with some security arrangement.\n### 3.2.2 Improvement 1\nTo enhance security of the system, we import the security module.\n1. To prevent information leaks, the client should not send the original fingerprint picture to the server.\n2. To prevent replay attack, the system can use a technology called one-time pad. It means that the key is valid only once. To achieve one-time pad system, we can take timestamp as a key. When user wants to authenticate the fingerprint, server-side checks the timestamp first, if the timestamp key is right, then the system do the matching. Otherwise, the system will not match the fingerprint with database.\n\nIn order to achieve the above two points, we combine barcode technology with our fingerprint system. First, server-side takes timestamp to encode a barcode picture and sends it to client. In this way, the barcode picture contains the timestamp information, it can be as a one-time key to prevent replay attack. Besides, we can combine the barcode picture with original fingerprint picture, then the client will use a new picture to instead of the original fingerprint picture. Finally, bar code technology meets the requirements of the above two aspects.\n![case 2](/images/thesis/chapter3/8.bmp)\nIn this case, user A take photos first, then he sends the request to server. The server takes current timestamp to generate a barcode picture and sends it back to client. After client receives the barcode picture, it sets the original fingerprint picture to the center of the barcode picture. Then the new picture will be send to the server. The server receives the new picture and decodes the barcode to check whether timestamp is correct. If it is the same as server-side timestamp, the system will send the picture to matching module. Otherwise, the server will return fail information to client.\n\nNow let's analyse security things of new system. The attacker B can still steal the picture which combines barcode with fingerprint image. But he cannot get the original fingerprint picture directly. What's more, he cannot do replay attack any longer. If he resends the picture which he intercepted, the timestamp of that picture is already useless because the timestamp of server-side is used before. So the server will not send the picture to matching module, it will return fail information to the attacker.\n\nThe security of our system has been improved. However, it's still not safe enough. The attackers have some methods to get the original fingerprint picture easily. They can cut down the center of the picture then they will get the original fingerprint picture, it is not hard. After they get the original fingerprint picture, they can send request to server to get a new qrcode picture. Then they can encode qrcode with original fingerprint image, it is a kind of replay attack. In this way, the timestamp is new and useful. The attackers will obtain system authentication successfully. So it is necessary to improve this solution to prevent this kind of phenomenon.\n### 3.2.3 Improvement 2\nThe basic idea will be not changed. The problem of the solution described above is that it just combines fingerprint picture with barcode picture directly. The fingerprint image is not hidden and is easy to reverse. So if we can use an algorithm to hide the fingerprint image, it will be hard to reverse. Then the system will be safer.\n\nA technology called reversible digital watermark will be applied in our system. Using this technology, we could combine fingerprint image with barcode image easily and the fingerprint image will be hidden at the same time. The fingerprint picture will be as watermark and it will not be sended to the server directly.  \n![case 3](/images/thesis/chapter3/9.bmp)\nThe solution is similar to the solution described in 3.2.2, we just use watermark technology in this solution. The client takes fingerprint picture as watermark and encodes it into the barcode picture. We will discuss algorithm in chapter 5. After encoding, the client sends the new picture to the server. The server-side receives the picture and calls decoding module to decode picture. After decoding, the server will separate fingerprint image from barcode picture. Then the system will check the timestamp and do the matching things.\n\nNow the system is safer than before. The attackers will not get the original fingerprint picture easily. They can only get qrcode picture while that picture is not useful for authentication. If attackers attempt to recover the original fingerprint picture, they must know the algorithm first. Howerver, if the attackers get the algorithm of encoding, the system is still unsafe. So we have to improve the system more.\n### 3.2.4 Improvement 3\nFinally, we add a key to the system.\n![case 4](/images/thesis/chapter3/10.bmp)\nIn this way, the attackers must get both key and algorithm to recover the original fingerprint picture. The cost is very high. So we think the system is safe enough.\n\n# 4 System Architecture\nChinese Version: [Chapter 3](http://lichcnpul.github.io/2015/06/26/3System-Architecture/) and [3.2 Nancy Framework](http://lichcnpul.github.io/2015/06/29/Nancy-Framework/)\nThis chapter will introduce system flow and the choice of architecture. This part will be divided to two parts. Part One introduces the specification of the hole system; Part Two discusses system framework and how it works.\n## 4.1 Basic Business Process\n### 4.1.1 Business Component\nBusiness component contains four parts:\n1. **Client**: smart phone(Android), fingerprint image acquisition module, feature extraction module, encryption module;\n\n2. **Server**: Web Sever，decryption module, authentication module, fingerprint matching module;\n\n3. **Third-party components**: Fingerprint Matcher SDK;\n\n4. **Database**: fingerprint image database, user database.\n\n### 4.1.2 Business Flow\nThe basic flow of the system is shown below:\n![basic flow](/images/thesis/chapter3/1.bmp)\nBusiness process consists of the following processes:\n1. **Fingerprint Image Acquisition**: User login android client, then the client calls camera and image acquisition module to get user fingerprint image.\n\n2. **Image Preprocessing and Feature Extraction**: The client calls feature extraction module to preprocess the fingerprint image and extract the feature of user's fingerprint.\n\n3. **Image Encryption**: First the client receives the QR Code information from server, then it calls encryption module to encode fingerprint image with QR Code information.\n\n4. **Image Upload**: The client calls Web API to upload the encrypted fingerprint images to the server.\n\n5. **Image Decryption**: The server calls decryption module to decode the encrypted fingerprint image, then it will get original fingerprint image and QR Code information.\n\n6. **User Authentication**: The server calls authentication module to check the QR Code information and ensure the authenticity of the user.\n\n7. **Fingerprint Matching**: The server calls Fingerprint Matcher SDK to compare user-uploaded fingerprint image with the fingerprint database, then it will get the matching score.\n\n8. **Result Display**: The server sends the matching score back to the client. Then the client determines whether the user is authenticated by matching score.\n\n## 4.2 SOA and Web Service\n### 4.2.1 SOA\nSOA is service-oriented architecture. Simple, SOA is a kind of new architecture to develop application system. In the system based on SOA architecture, functionality of the application is a combination of the components together. These components are loosely coupled and have a unified interface definitions, we often called the components as service. The advantages of SOA architecture is to achieve cross-platform and scalability of application system.\n\nFor example, in our fingerprint authentication system, now we need achieve an Android client and a server-side. Android client communicates with server-side and calls the API provided by server to achieve the functions of fingerprint upload and fingerprint authentication. In the traditional software architecture, the client and server development should be in the same technical architecture, for example, if the client uses Android technology, the server should also use Java EE technology; if the client uses Windows Phone technology, the server should also use .net framework. The software architecture model is a tightly coupled architecture. The advantage of this model is close cooperation, and the client and server both call the same underlying module. However, the disadvantage of this model is bad scalability. If you use .net technology to develop client side, the server-side has to use the same technology. This kind of architecture is not suitable for the development of mobile internet.\n\nIn the mobile Internet era, a service often provides support for a variety of clients. For example, social software \"Line\" has some service for clients. The login service needs provide support for PC clients, it also needs provide support for Android clients and iOS clients, even it need provide the service for browser. If we use traditional system architecture, we have to write service code for every platform. However, the service code is almost the same. It does not conform the software engineering principle of DRY(Don‘t Repeat Yourself). In this background, SOA architecture have been developed rapidly.\n\nIn SOA architecture each application functions will be packaged as service, while these services are platform-independent. Client communicates with server by message delivery. When the client needs call server API, it can send a message to the server interface, thus achieving the transformation of architecture from specific technology-oriented to service-oriented. Whether the client uses Android technology, or iOS technology, or web technology, or desktop technology, it can call the same service while it is not necessary to change any code in server-side. The SOA architecture model greatly enhanced cross-platform and scalability of application system, now SOA has became mainstream architecture model in mobile Internet era. Web Service is a kind of technology to achieve SOA.\n![SOA](/images/thesis/chapter3/2.bmp)\n### 4.2.2 Web Service\nWeb Service is one of the most commonly used techniques to achieve SOA. It provides services through a standard web protocol, the purpose of Web service is to ensure that different applications can interoperate.（[Web Service](https://en.wikipedia.org/wiki/Web_service)）\n\nAfter years of development, there are two main types of web service currently .\n1. SOAP-based Web Service\n2. REST-based Web Service\n\nSOAP-based Web Service: SOAP is used to describe the format of the information transmitted, WSDL is used to describe how to access specific interface, UDDI is used to manage, distribute, query Web Service. SOAP uses two protocols have been widely used: HTTP and XML(a subset of Standard Generalized Markup Language). HTTP is used to implement RPC-style SOAP transmissions, and XML is its encoding format. By using SOAP, Web Service has a good scalability, completely independent of the vendor, programming language and platform.\n\nREST-based Web Service: Dr. RT Fielding's doctoral dissertation \"Architectural Styles and the Design of Network-based Software Architectures\" laid the basis for REST-style Web Service. REST is Representational State Transfer. It has the following characteristics:\n1. First REST is a style, not a standard.\n2. REST is based on resource.\n3. The purpose of REST is to decide how to make a well defined web application forward.\n4. REST makes full use of HTTP　protocol.\n* It locates resources by logic URI.\n* It distinguishes what format of data the client wants to get by HTTP Request Header Information.\n* In REST architecture, the CRUD(create,read,update and delete) operation is handled by using different HTTP request methods.\n\n![REST API](/images/thesis/chapter3/3.bmp)\nThe characteristics of REST style make it more lightweight than SOAP, fuller use HTTP protocol. REST really expresses the original intention of HTTP protocol. REST has completely changed the status of Web Service, adapted to the trend of mobile internet, and now the mainstream mobile client development has shifted to the REST style Web Service. In order to achieve the Android client of fingerprint verification, we also use REST style Web Service in our system.\n## 4.3 Nancy Framework  \nWe use Nancy Framework to achieve a lightweight REST-style Web Service. Nancy Framework is a lightweight web framework based on .Net and mono platforms, it follows the MVC model and is designed to provide REST-style Web Service. On its [official website](http://nancyfx.org/) , it introduces the following features of Nancy:\n1. Nancy is a lightweight, low-ceremony, framework for building HTTP based services on .Net and Mono. The goal of the framework is to stay out of the way as much as possible and provide a super-duper-happy-path to all interactions.\n2. Nancy is designed to handle DELETE, GET, HEAD, OPTIONS, POST, PUT and PATCH requests and provides a simple, elegant, Domain Specific Language (DSL) for returning a response with just a couple of keystrokes.\n3. Nancy is built to run anywhere.\n\n### 4.3.1 MVC\nThe design ideas of Nancy Framework comes from Ruby's Sinatra Framework, whose basic idea is MVC model. MVC model is Model-View-Controller mode.\n* Model is a part of application system to deal with data logic, typically used to encapsulate data objects to store data.\n* View is a part of application system to display data to user. View data usually need to be obtained from model.\n* Controller is responsible for reading data from the view, controlling user input, and sending data to the model.\n\n![MVC](/images/thesis/chapter3/4.bmp)\nThe figure shows the basic principle of MVC model:\n1. First, user sends a request to the application, waiting for the server to respond.\n2. Controller receives the user request, then it decides which model or view to respond according to the header of request.\n3. Controller sends data requests to model.\n4. Model gets data from database and returns the data to controller\n5. controller sends the acquired data to the corresponding view.\n6. Fill view according to the model data, and return the results to the controller.\n7. Controller returns view to user.\n\nThrough MVC model, the separation of application business logic and performance is realized. It also reduces the coupling between modules. Now more and more application systems are using MVC model, many frameworks also follow the MVC model, such as Ruby on Rails, Java Spring MVC, ASP.net MVC etc.. The Nancy Framework which we used is also a super lightweight MVC framework on .net platform.\n### 4.3.2 Nancy Framework\nNancy Framework is a super lightweight web framework on .net platform based on MVC mode. The structure of Nancy project is shown below:\n![Nancy](/images/thesis/chapter3/5.png)\nIn Nancy Framework, Model is M, Views is V, Module is C.\n1. Controller uses rest style, the basic mode is as follows: when user inputs uri http://hostaddress/ in the browser, the controller class of Nancy framework will match the corresponding controller based on uri firstly. This mechanism is called Route mechanism, it is the core of Nancy Framework to achieve REST-style controller. When a user requests the resources on root directory in 'GET' method, the controller will find the GET[\"/\"] controller based on Route mechanism. After the match is successful, the user request is processed by the controller. The controller can call the corresponding view resources and model resources in response to user requests.\n``` csharp\nGet[\"/\"] = parameters =>\n{\n    return View[\"index\"];\n};\n```\n2. View takes HTML as the basic style, the official supported view engine is Radar engine, the syntax of Radar is similar to HTML.\n``` html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Fingerprint Web Service Page</title>\n</head>\n<body>\n    Content\n</body>\n</html>\n```\n3. Model generally takes Database as objects and supports most of the ORM framework.\n\n## 4.4 System Architecture Diagram\nThe architecture diagram of the fingerprint identification system is as follows:\n![System Architecture](/images/thesis/chapter3/6.bmp)\n\n# 5 Algorithm\n## 5.1 Display Matrix\nSuppose the QR Code image matrix is：\n\n$Q=\\begin{bmatrix}\n255 & 254 & 255 & 1 & 2 & \\cdots\\\\\\\n255 & 255 & 255 & 1 & 1 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nIts binary form is：\n\n$Q=\\begin{bmatrix}\n111111\\color{red}{11} & 111111\\color{red}{10} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{10} & \\cdots\\\\\\\n111111\\color{red}{11} & 111111\\color{red}{11} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{01} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nThe watermark image matrix is:\n\n$M=\\begin{bmatrix}\n167 & 63 & 15 & \\cdots\\\\\\\n255 & 127 & 128 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nIts binary form is:\n\n$M=\\begin{bmatrix}\n10100111 & 00111111 & 00001111 & \\cdots\\\\\\\n11111111 & 01111111 & 10000000 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nNow we will separate the watermark matrix to encode it to the QRcode matrix.\nLet's focus the watermark matrix first.\n## 5.2 Watermark Matrix\nFor the watermark matrix above, we called it M, we can see M(1,1)=167, in binary form, M(1,1)=10100111. We separate it to 4 parts.\n\n<strong><font color=\"red\" size=\"6\">10</font></strong><strong><font color=\"green\" size=\"6\">10</font></strong><strong><font color=\"blue\" size=\"6\">01</font></strong><strong><font color=\"yellow\" size=\"6\">11</font></strong>\n\n1. The Red Part: the 1-2 bit\n2. The Green Part: the 3-4 bit\n3. The Blue Part: the 5-6 bit\n4. The Yellow Part: the 7-8 bit\n\nThen we can get 4 matrix from 4 parts:\n1.The Red Part Matrix is:\n\n$M1=\\begin{bmatrix}\n10 & 00 & 00 & \\cdots\\\\\\\n11 & 01 & 10 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 0 & 0 & \\cdots\\\\\\\n3 & 1 & 2 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n2.The Green Part Matrix is:\n\n$M2=\\begin{bmatrix}\n10 & 11 & 00 & \\cdots\\\\\\\n11 & 11 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 3 & 0 & \\cdots\\\\\\\n3 & 3 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n3.The Blue Part Matrix is:\n\n$M3=\\begin{bmatrix}\n01 & 11 & 11 & \\cdots\\\\\\\n11 & 01 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n1 & 3 & 3 & \\cdots\\\\\\\n3 & 1 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n4.The Yellow Part Matrix is:\n\n$M4=\\begin{bmatrix}\n11 & 11 & 11 & \\cdots\\\\\\\n11 & 11 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n3 & 3 & 3 & \\cdots\\\\\\\n3 & 3 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n## 5.3 Encoding Method\n### 5.3.1 Why we can encode QRCode Image with watermark image?\nThe QRCode Image is bigger than watermark image. The rows of QRCode image is 3 times higher than watermark image; the colmns is 5 times higher than watermark image. So we can embed the watermark matrix into qrcode matrix. It is very important. In our method, the watermark matrix M is a 392\\*357 matrix; the qrcode matrix Q is a 900\\*5000 matrix.\n\nIn addition, the QRCode image and watermark image are both grayscale images.\n### 5.3.2 How to encode?\nWe use Least Significant Bit Algorithm. First, we separate matrix Q to 5 parts.\n\n$Q=\\begin{bmatrix}\nA&B& \\\\\\\nC&D& \\\\\\\n & &E\n\\end{bmatrix}$\n\nFor matrix A,B,C,D, they are all 392\\*357 matrix. E is the rest part of Q.\nThen we use A,B,C,D and M1,M2,M3,M4 to encode. We set the least 2 bits of A,B,C,D to 0. For example:\n\n$A=\\begin{bmatrix}\n111111\\color{red}{11} & 111111\\color{red}{10} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{10} & \\cdots\\\\\\\n111111\\color{red}{11} & 111111\\color{red}{11} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{01} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nset the least 2 bits to 0:\n\n$A1=\\begin{bmatrix}\n111111\\color{red}{00} & 111111\\color{red}{00} & 111111\\color{red}{00} & 000000\\color{red}{00} & 000000\\color{red}{00} & \\cdots\\\\\\\n111111\\color{red}{00} & 111111\\color{red}{00} & 111111\\color{red}{00} & 000000\\color{red}{00} & 000000\\color{red}{00} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nthen we use matrix M1 instead of the least 2 bits of A:\n```python\nA2 = A1 + M1\n```\nFor B,C,D and M2,M3,M4 ,we do the some operation:\n```python\nB2 = B1 + M2\nC2 = C1 + M3\nD2 = D1 + M4\n```\nAfter that, we will get a new matrix called Q2:\n\n$Q2=\\begin{bmatrix}\nA2&B2& \\\\\\\nC2&D2& \\\\\\\n & &E\n\\end{bmatrix}$\n\nThe matrix Q2 contains all the information of watermark images. Now we have realized Encoding Module.\n\n## 5.4 Decoding Method\nIt is easy to get the watermark matrix. From Q2 we can extract A2,B2,C2,D2, then we will get M1,M2,M3,M4 by mod([A2,B2,C2,D2],4).\n```python\nM1(i,j) = A2(i,j) mod 4\nM2(i,j) = B2(i,j) mod 4\nM3(i,j) = C2(i,j) mod 4\nM4(i,j) = D2(i,j) mod 4\n```\nFrom M1, M2, M3, M4, we will recover watermark matrix easily.\n```python\nM(i,j)=M4(i,j)＋4 * M3(i,j)＋16 * M2(i,j)＋64 * M1(i,j)\n```\nIn this way, now we have already recover the watermark matrix.\n# 6 Fingerprint Matching\n## 6.1 Basic concept\n## 6.2 Exist Tools\n## 6.3 SourceAFIS\n# 7 Communication and Results\n# 8 Conclusion\n# Reference\n","slug":"150703-thesis","published":1,"updated":"2015-07-09T09:27:57.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03ge60000n8svmzthvu79"},{"title":"thesis","date":"2015-07-01T12:29:23.000Z","toc":true,"_content":"# Network-based Fingerprint Authentication System Using a Mobile Device\n## Abstract:\nPresent fingerprint system has problems in security, usability and cost. In this case, we propose a touch-less fingerprint authentication method.  Use mobile device’s built-in camera to capture fingerprint image, and then send it to the server to complete the identity authentication work. Based on this method, the system comprises capture, preprocessing, matching stages and is implemented in a prototype as application for the Android OS. The experimental results show that our method is feasible and lets off some potential problems in the touch-based fingerprint technology.\n## Key words:\n*Fingerprint authentication*, *touch-less*, *network-based*, *mobile device*\n## 1 Introduction\nMore than a century has passed since the Home Ministry Office, UK, accepted that no two individuals have the same fingerprints and then industriously practiced the idea for solving crimes [1]. Nowadays, due to increasing concerns about security and identity fraud have created a growing need for fingerprint for person recognition, fingerprint authentication is not only needed in forensic applications, but also in a large number of non-forensic applications. The present fingerprint authentication systems are generally called Automatic Fingerprint Identification Systems (AFIS). AFIS accept live-scan digital images acquired with an electronic fingerprint scanner where the finger surface is directly sensed.\n\nHowever, the seems-good system has the potential problems in security, usability and cost. For example, an e-payment in a convenient store, a usual procedure is (1) put a finger on the scanner for ensuring (2) the POS deals with obtained fingerprint according to the local database (3) if the fingerprint is matched, e-payment is completed. In this process, security problems happens, which fingerprint left on the reader may be duplicated by others and applications may leak fingerprint information. In usability aspect, fingerprint system (FP System) is wired and bulky. The other problem is FP system equipment is expensive and maintenance expense is cost, for instance software updating and hardware upgrading both cost money.\n\nDue to the case above, this paper proposes a network-based finger authentication using a camera. This method is that user uses mobile device’s built-in camera to capture fingerprint (FP) image, and send preprocessed FP image to the server through Internet, then the server send back feedback after matches this FP image with initial fingerprint stored in database. The client reacts according to the feedback.\n\nAllowing for smartphone’s some advantages:  (1) the build-in camera has zooming, auto-focusing and high resolution that is suitable to capture high quality images (2)affordable cost [2] (3)the enough computational capacities to process the photos and execute algorithms, we opted for the smartphone as our experiment tool.  There are no extra devices needed to perform the proposed solution. The capture process is touch-less, so no latent fingerprint is left. In addition, sending FP and receiving feedback is wireless, just through the Internet, hence, it is convenient.  Compared with present AFIS, our method is much safer, stronger usability and less cost.\n\nThe rest of the paper is organized as follows. Section 2 will talk about related works in the touch-less finger recognition. Section 3 will discuss the challenges of fingerprint image authentication. Section 4 will talk about procedure and detailed algorithm design. Section 5 will show the basic architecture of the system. Section 6 will show experiment results. Section 7 is discussion. Section 8 is the conclusion.\n\n## 2 Background\n### 2.1 Biometrics System Model\nBiometric systems generally comprise three basic components [3]:\n* An automated mechanism scans and captures a digital or analogue image of a living individual’s characteristics.\n* Another mechanism handles compression, processing, storage and comparison of the collected data with the stored data.\n* A third component interfaces with the application system to which the user is attempting to gain access.\n\nObviously, the configuration of such a system may be altered to suit a particular situation. However, the majority of biometric control systems follow this simple model.\n\nIt should be noted that there is one crucial step required in setting up a biometric system: enrollment. The only way to gain access to a biometrical controlled system is to enroll.\n\nEnrollment is required to generate a reference template. The methods of enrollment vary according to the device used but usually involve scanning the required biometric data a number of times to gain an accurate measurement. A template is then created and linked to the user’s identity. This template provides the reference for comparison when access attempts are made.\n\n### 2.2 Overview of current AFIS\nGenerally, a fingerprint system designer make sure that the system makes the correct trade-offs. These trade-offs may include recognition accuracy, response time, system integrity, complexity, cost (component price as well as integration and support costs), privacy, government standards, liveness detection, ease of integration, durability, modality of usage, etc. A good fingerprint recognition system should provide a good balance of security, privacy, convenience, and accountability.\n\nBased on the model above, current AFIS is consists of sensors, fingerprint processing and matching hardware and software. Because of fingerprint recognition’s advantages, AFIS are now being increasingly used in many fields.\n![Figure 1](/images/thesis2/image1.png)\nFigure 1 shows various applications involving electronic access or transaction that require reliable automatic user recognition.\n## 2.3 Fingerprint authentication in Electronic Payment\nAn application in E-payment using fingerprint authentication is called fingerprint payment system. Fingerprint payment system allows the consumer to pay with the touch of a finger on a fingerprint scanner. Biometric payment providers require completion of a pre-enrollment process in which index fingers are scanned and address and banking information is recorded in an account database [12]. This transactions process reportedly takes a few seconds. The service was launched in United States in 2005 and spread swiftly into worldwide. For example, Walmart, 7-11 and Taobao all support the service.\n![Figure 2](/images/thesis2/image2.png)\nFigure 2 shows the workflow and its problems.\n## 2.4 Disadvantages of touch based sensors\nThe sensor is the most critical component of the entire fingerprint recognition process. Recognition is highly dependent on the quality of the captured fingerprint image as in less noise, and better image. The core technology used to manufacture the sensors can introduce noise and errors on the captured fingerprint image, influencing the recognition to such a negative extreme that you could be continuously rejected by the system (false rejection) or somebody else could be granted access to the system instead of you (false acceptance).\n\nCurrent fingerprint capture method is touch-based. In order to acquire fingerprint images, the touch-based fingerprint sensors require the user to place his finger on the flat window of the sensor. Because the skin of the finger is not flat, the user must apply enough pressure on the window to obtain sufficient size and achieve good image quality. However, this pressure produces unavoidable physical distortion in arbitrary directions, which is represented differently throughout every area of the same fingerprint image [4] .During the touch, the fingerprint can be acquired with different technologies. There are two main types of touch-based technologies: optical sensors and IC’s or CMOS sensors. Optical sensors are more accurate than IC’s, but they have the similar problems of above.\n![Figure 3](/images/thesis2/image3.png)\nFigure 3 shows the images from touch based sensor using different impression strength.\n\nAs the sensor’s protecting layer is thin, its continuous usage will destroy its surface, making the device useless. In everyday life, things are even worst. You usually use your hands for different tasks and you usually touch different types of materials. Small portions of the objects you touch accumulate on the skin of your finger. When you touch the fingerprint sensor, you deposit these materials on its surface. Additionally, your skin produces sweat (a combination of water and different types of salts) and the sebum (an oily/waxy substance our body produces). When you touch the surface of a fingerprint sensor, the mix of the sweat, sebum and any substance accumulate during your daily activities become a killer combination for the sensor surface that speeds up the destruction of its surface. Fingerprint sensor manufacturers never achieved great success in this issue.\n\nMeanwhile, after pressing on the surface, a latent fingerprint will be left on it. A latent fingerprint refers to the trail of fingerprint on the surface of the sensor. This can lead to fraudulent use, such as the faking of fingerprints, as well as hygienic problems.\n![Figure 4](/images/thesis2/image4.png)\nFigure 4 shows the latent fingerprint on a sensor [1].\n\nIn addition, a set of fingerprint recognition system equipment is expensive and its maintenance expense is cost, for instance software updating and hardware upgrading both cost money.\n\nAs shown above in Figure 2, current fingerprint authentication system based on touched sensors almost have similar problems.\n\n## 3 Related Work\nTo date, several approaches for touch-less fingerprint recognition system have been reported. Application of fingerprint verification technology to mobile handsets is discussed in [5] and a novel method for fingerprint enhancement has been developed for that particular design[5, 6]. In [11] , the authors proposed a preprocessing technique which included low pass filtering, segmentation and Gabor enhancement for their own-designed touch-less sensor. Later,[7] resolved the 3D to 2D image mapping problem that was introduced in [11] by a strong view difference image rejection method. Preprocessing of fingerprint images captured with mobile camera was suggested by [8]. Most lately, [9] introduced a new touch-less device - The Surround Imager, which can acquire 3D rolled-equivalent fingerprints. To make 3D touch-less fingerprints interoperable with the current AFIS system, [10] proposed an unwrapping algorithm that unwraps the 3D touch-less fingerprint images into 2D representations that are comparable with the legacy rolled fingerprints.\n\n## 4 Proposal Solution\nTo solve these problems, this paper proposes a network-based finger authentication using mobile device. This method is that user uses mobile device’s built-in camera to capture fingerprint (FP) image, and send preprocessed FP image to the server through Internet, then the server send back feedback after matches this FP image with initial fingerprint stored in database. The client reacts according to the feedback.\n\nThe capture process with fingerprint is performed touch-less, just use smartphone camera. Hence, no latent fingerprint is left, privacy leak and hygienic problems won’t be worried any more.\n\nThe other advantage of the touch-less method compared to the touch-based ones is that, since the finger does not need to touch any rigid surfaces, the skin does not deform and the image captures very rich details that can make the recognition more accurate.\n\nIn addition, network-based system make fingerprint recognition work be done anywhere and anytime. It is much more convenient than the way that you have to go to somewhere and use certain sensor.\n\nAt last, current smartphone is good enough to capture the finger in sufficient quality and process the photos and execute algorithms for fingerprint recognition. Apart of this, there are no extra devices. And a smartphone is durable to use, so maintenance charge is small.\nIn general, out proposal solution will be safer, convenient and cost less.\n![Figure 5](/images/thesis2/image5.png)\nFigure 5 shows our proposed solution and advantages.\n\n## 5 Method\nThe proposed method includes Image obtain, Image preprocessing, Image Enhancement, Feature Extraction and Matching Stages.\n### 5.1 Image Obtain\nThis part contains capture process and quality assurance.\n**Capture Process**\nThe intention of the fingerprint recognition is that for authentication the user simply positions his finger close in front of the camera in order to capture a biometric sample. The focus is set to “macro mode”, such that the camera uses the closest possible focus. The LED is switched on during the capture process. The LED spotlights the finger such that it appears brighter than the background. This simplifies the segmentation of the finger against the background. Another advantage is the reduced camera noise and risk of blurring caused from hand-motion due the high brightness from the LED. The LED also stabilizes the lighting conditions and creates more homogeneous illumination.\n**Quality Assurance**\nThe algorithms for finger detection and quality assurance check continuously the preview images of the camera after the capture process has been initiated by the user. The results of the algorithms are calculated in real-time and are displayed on the graphical user interface of the developed prototype. A photo is automatically taken when all criteria (see Section 7) for the fingerprint recognition are fulfilled.\n\nQuality Estimation: Based on the gradient distribution of an ideal fingerprint, calculate to estimate subject image’s coherence and symmetrization.\n\n### 5.2 Image Preprocessing\nSkin Color Detection\nOstu Adaptive Thresholding\nMorphological Processing\nNormalization\n### 5.3 Image Enhancement\nMedian Filtering\nBicubic Interpolation\nHistogram Equalization\nGaussian Filtering\nCore Point Detection: the Poincare index\nCropping 353*392 size\n### 5.4 Feature Extraction\nAFIS Open Source Engine\n### 5.5 Matching\nUsing AFIS Open Source Engine to get two compared fingerprints score.\n\n## 6 Results\nWe chose two group fingerprint sample. Each of them contains 30 finger images and then we compared the two group samples with corresponding database fingerprints. Through analyzing the resulting score matrix, the first group: false reject number is 8, FRR is 0.888%, false accept number is 0, FAR is 0%; the second group:  false reject number is 1, FRR is 0.111%, false accept number is 2, FAR is 0.222%\n## 7 Discussion\nThe experiment  results has been shown that fingerprint recognition on smartphones is possible. A capture process for fingerprint in combination with efficient processing algorithms was developed. The implemented algorithms ensure the suitability of the captured photos for fingerprint recognition.\n## Reference\n[1] D. Maltoni, D. Maio, A. K.Jain, and S. Prabhakar, Handbook of Fingerprint Recognition, Springer- Verlag, New York, 2003.\n[2] B.Y. Hiew, Andrew B.J. Teoh, Member, IEEE and Y.H. Pang, Digital Camera based Fingerprint Recognition, Proceedings of the 2007 IEEE International Conference on Telecommunications and Malaysia International Conference on Communications, 14-17 May 2007, Penang, Malaysia.\n[3] Rodger Jamieson, Ph.D., CA, Greg Stephens and Santhosh Kumar, Fingerprint Identification: An Aid to the Authentication Process, 2005 Information Systems Audit and Control Association.\n[4] Jainam Shah*, Ujash Poshiya, Touchless Fingerprint Reorganization, Vishwakarma Government Engineering College, Chandkheda Gujarat, India.\n[5] M. Hashimoto, S. Tanaka, and J. Thornton, \"Biometrics in Mobile Handsets\", Technical Report, Mitsubishi Electric Corporation, June 2005.\n[6] T. Nakamura, H. Fujiwara, M. Hirooka, and K. Sumi, \"Fingerprint Enhancement Using a Parallel Ridge Filter\", 17th International Conference on Pattern Recognition 2004, Cambridge, United Kingdom, 2004.\n[7] C. Lee, S. Lee, and J. Kim, \"A Study of Touchless Fingerprint Recognition System\", Joint IAPR International Workshops, SSPR 2006 and SPR 2006, Hong Kong, China, 2006.\n[8] C.H. Lee, S.H. Lee, J.H. Kim, and S.J. Kim, \"Preprocessing of a Fingerprint Image Captured with a Mobile Camera \", Advances in Biometrics: International Conference, Hong Kong, China, 2006.\n[9] G. Parziale and E. Diaz-Santana, \"The Surround Imager: A Multi-camera Touchless Device to Acquire 3D Rolled-Equivalent Fingerprints\", IAPR International Conference on Biometrics, Hong Kong, China, 2006.\n[10] Y. Chen, G. Parziale, E. Diaz-Santana, and A. Jain, \"3D Touchless Fingerprints: Compatibility with Legacy Rolled Images\", Proceeding of Biometric Symposium, Biometric Consortium Conference, Baltimore,MD, U.S.A, 2006.\n[11] Y. Song, C. Lee, and J. Kim, \"A New Scheme for Touchless Fingerprint Recognition System\", International Symposium on Intelligent Signal Processing and Communication Systems, Korea, 2004\n[12] Dileep Kumar, Yeonseung Ryu, A Brief Introduction of Biometrics and Fingerprint Payment Technology , International Journal of Advanced Science and Technology Vol. 4, March, 2009\n","source":"_posts/thesis.md","raw":"title: thesis\ndate: 2015-07-01 21:29:23\ncategories: Zhang's Thesis\ntags: thesis\ntoc: true\n---\n# Network-based Fingerprint Authentication System Using a Mobile Device\n## Abstract:\nPresent fingerprint system has problems in security, usability and cost. In this case, we propose a touch-less fingerprint authentication method.  Use mobile device’s built-in camera to capture fingerprint image, and then send it to the server to complete the identity authentication work. Based on this method, the system comprises capture, preprocessing, matching stages and is implemented in a prototype as application for the Android OS. The experimental results show that our method is feasible and lets off some potential problems in the touch-based fingerprint technology.\n## Key words:\n*Fingerprint authentication*, *touch-less*, *network-based*, *mobile device*\n## 1 Introduction\nMore than a century has passed since the Home Ministry Office, UK, accepted that no two individuals have the same fingerprints and then industriously practiced the idea for solving crimes [1]. Nowadays, due to increasing concerns about security and identity fraud have created a growing need for fingerprint for person recognition, fingerprint authentication is not only needed in forensic applications, but also in a large number of non-forensic applications. The present fingerprint authentication systems are generally called Automatic Fingerprint Identification Systems (AFIS). AFIS accept live-scan digital images acquired with an electronic fingerprint scanner where the finger surface is directly sensed.\n\nHowever, the seems-good system has the potential problems in security, usability and cost. For example, an e-payment in a convenient store, a usual procedure is (1) put a finger on the scanner for ensuring (2) the POS deals with obtained fingerprint according to the local database (3) if the fingerprint is matched, e-payment is completed. In this process, security problems happens, which fingerprint left on the reader may be duplicated by others and applications may leak fingerprint information. In usability aspect, fingerprint system (FP System) is wired and bulky. The other problem is FP system equipment is expensive and maintenance expense is cost, for instance software updating and hardware upgrading both cost money.\n\nDue to the case above, this paper proposes a network-based finger authentication using a camera. This method is that user uses mobile device’s built-in camera to capture fingerprint (FP) image, and send preprocessed FP image to the server through Internet, then the server send back feedback after matches this FP image with initial fingerprint stored in database. The client reacts according to the feedback.\n\nAllowing for smartphone’s some advantages:  (1) the build-in camera has zooming, auto-focusing and high resolution that is suitable to capture high quality images (2)affordable cost [2] (3)the enough computational capacities to process the photos and execute algorithms, we opted for the smartphone as our experiment tool.  There are no extra devices needed to perform the proposed solution. The capture process is touch-less, so no latent fingerprint is left. In addition, sending FP and receiving feedback is wireless, just through the Internet, hence, it is convenient.  Compared with present AFIS, our method is much safer, stronger usability and less cost.\n\nThe rest of the paper is organized as follows. Section 2 will talk about related works in the touch-less finger recognition. Section 3 will discuss the challenges of fingerprint image authentication. Section 4 will talk about procedure and detailed algorithm design. Section 5 will show the basic architecture of the system. Section 6 will show experiment results. Section 7 is discussion. Section 8 is the conclusion.\n\n## 2 Background\n### 2.1 Biometrics System Model\nBiometric systems generally comprise three basic components [3]:\n* An automated mechanism scans and captures a digital or analogue image of a living individual’s characteristics.\n* Another mechanism handles compression, processing, storage and comparison of the collected data with the stored data.\n* A third component interfaces with the application system to which the user is attempting to gain access.\n\nObviously, the configuration of such a system may be altered to suit a particular situation. However, the majority of biometric control systems follow this simple model.\n\nIt should be noted that there is one crucial step required in setting up a biometric system: enrollment. The only way to gain access to a biometrical controlled system is to enroll.\n\nEnrollment is required to generate a reference template. The methods of enrollment vary according to the device used but usually involve scanning the required biometric data a number of times to gain an accurate measurement. A template is then created and linked to the user’s identity. This template provides the reference for comparison when access attempts are made.\n\n### 2.2 Overview of current AFIS\nGenerally, a fingerprint system designer make sure that the system makes the correct trade-offs. These trade-offs may include recognition accuracy, response time, system integrity, complexity, cost (component price as well as integration and support costs), privacy, government standards, liveness detection, ease of integration, durability, modality of usage, etc. A good fingerprint recognition system should provide a good balance of security, privacy, convenience, and accountability.\n\nBased on the model above, current AFIS is consists of sensors, fingerprint processing and matching hardware and software. Because of fingerprint recognition’s advantages, AFIS are now being increasingly used in many fields.\n![Figure 1](/images/thesis2/image1.png)\nFigure 1 shows various applications involving electronic access or transaction that require reliable automatic user recognition.\n## 2.3 Fingerprint authentication in Electronic Payment\nAn application in E-payment using fingerprint authentication is called fingerprint payment system. Fingerprint payment system allows the consumer to pay with the touch of a finger on a fingerprint scanner. Biometric payment providers require completion of a pre-enrollment process in which index fingers are scanned and address and banking information is recorded in an account database [12]. This transactions process reportedly takes a few seconds. The service was launched in United States in 2005 and spread swiftly into worldwide. For example, Walmart, 7-11 and Taobao all support the service.\n![Figure 2](/images/thesis2/image2.png)\nFigure 2 shows the workflow and its problems.\n## 2.4 Disadvantages of touch based sensors\nThe sensor is the most critical component of the entire fingerprint recognition process. Recognition is highly dependent on the quality of the captured fingerprint image as in less noise, and better image. The core technology used to manufacture the sensors can introduce noise and errors on the captured fingerprint image, influencing the recognition to such a negative extreme that you could be continuously rejected by the system (false rejection) or somebody else could be granted access to the system instead of you (false acceptance).\n\nCurrent fingerprint capture method is touch-based. In order to acquire fingerprint images, the touch-based fingerprint sensors require the user to place his finger on the flat window of the sensor. Because the skin of the finger is not flat, the user must apply enough pressure on the window to obtain sufficient size and achieve good image quality. However, this pressure produces unavoidable physical distortion in arbitrary directions, which is represented differently throughout every area of the same fingerprint image [4] .During the touch, the fingerprint can be acquired with different technologies. There are two main types of touch-based technologies: optical sensors and IC’s or CMOS sensors. Optical sensors are more accurate than IC’s, but they have the similar problems of above.\n![Figure 3](/images/thesis2/image3.png)\nFigure 3 shows the images from touch based sensor using different impression strength.\n\nAs the sensor’s protecting layer is thin, its continuous usage will destroy its surface, making the device useless. In everyday life, things are even worst. You usually use your hands for different tasks and you usually touch different types of materials. Small portions of the objects you touch accumulate on the skin of your finger. When you touch the fingerprint sensor, you deposit these materials on its surface. Additionally, your skin produces sweat (a combination of water and different types of salts) and the sebum (an oily/waxy substance our body produces). When you touch the surface of a fingerprint sensor, the mix of the sweat, sebum and any substance accumulate during your daily activities become a killer combination for the sensor surface that speeds up the destruction of its surface. Fingerprint sensor manufacturers never achieved great success in this issue.\n\nMeanwhile, after pressing on the surface, a latent fingerprint will be left on it. A latent fingerprint refers to the trail of fingerprint on the surface of the sensor. This can lead to fraudulent use, such as the faking of fingerprints, as well as hygienic problems.\n![Figure 4](/images/thesis2/image4.png)\nFigure 4 shows the latent fingerprint on a sensor [1].\n\nIn addition, a set of fingerprint recognition system equipment is expensive and its maintenance expense is cost, for instance software updating and hardware upgrading both cost money.\n\nAs shown above in Figure 2, current fingerprint authentication system based on touched sensors almost have similar problems.\n\n## 3 Related Work\nTo date, several approaches for touch-less fingerprint recognition system have been reported. Application of fingerprint verification technology to mobile handsets is discussed in [5] and a novel method for fingerprint enhancement has been developed for that particular design[5, 6]. In [11] , the authors proposed a preprocessing technique which included low pass filtering, segmentation and Gabor enhancement for their own-designed touch-less sensor. Later,[7] resolved the 3D to 2D image mapping problem that was introduced in [11] by a strong view difference image rejection method. Preprocessing of fingerprint images captured with mobile camera was suggested by [8]. Most lately, [9] introduced a new touch-less device - The Surround Imager, which can acquire 3D rolled-equivalent fingerprints. To make 3D touch-less fingerprints interoperable with the current AFIS system, [10] proposed an unwrapping algorithm that unwraps the 3D touch-less fingerprint images into 2D representations that are comparable with the legacy rolled fingerprints.\n\n## 4 Proposal Solution\nTo solve these problems, this paper proposes a network-based finger authentication using mobile device. This method is that user uses mobile device’s built-in camera to capture fingerprint (FP) image, and send preprocessed FP image to the server through Internet, then the server send back feedback after matches this FP image with initial fingerprint stored in database. The client reacts according to the feedback.\n\nThe capture process with fingerprint is performed touch-less, just use smartphone camera. Hence, no latent fingerprint is left, privacy leak and hygienic problems won’t be worried any more.\n\nThe other advantage of the touch-less method compared to the touch-based ones is that, since the finger does not need to touch any rigid surfaces, the skin does not deform and the image captures very rich details that can make the recognition more accurate.\n\nIn addition, network-based system make fingerprint recognition work be done anywhere and anytime. It is much more convenient than the way that you have to go to somewhere and use certain sensor.\n\nAt last, current smartphone is good enough to capture the finger in sufficient quality and process the photos and execute algorithms for fingerprint recognition. Apart of this, there are no extra devices. And a smartphone is durable to use, so maintenance charge is small.\nIn general, out proposal solution will be safer, convenient and cost less.\n![Figure 5](/images/thesis2/image5.png)\nFigure 5 shows our proposed solution and advantages.\n\n## 5 Method\nThe proposed method includes Image obtain, Image preprocessing, Image Enhancement, Feature Extraction and Matching Stages.\n### 5.1 Image Obtain\nThis part contains capture process and quality assurance.\n**Capture Process**\nThe intention of the fingerprint recognition is that for authentication the user simply positions his finger close in front of the camera in order to capture a biometric sample. The focus is set to “macro mode”, such that the camera uses the closest possible focus. The LED is switched on during the capture process. The LED spotlights the finger such that it appears brighter than the background. This simplifies the segmentation of the finger against the background. Another advantage is the reduced camera noise and risk of blurring caused from hand-motion due the high brightness from the LED. The LED also stabilizes the lighting conditions and creates more homogeneous illumination.\n**Quality Assurance**\nThe algorithms for finger detection and quality assurance check continuously the preview images of the camera after the capture process has been initiated by the user. The results of the algorithms are calculated in real-time and are displayed on the graphical user interface of the developed prototype. A photo is automatically taken when all criteria (see Section 7) for the fingerprint recognition are fulfilled.\n\nQuality Estimation: Based on the gradient distribution of an ideal fingerprint, calculate to estimate subject image’s coherence and symmetrization.\n\n### 5.2 Image Preprocessing\nSkin Color Detection\nOstu Adaptive Thresholding\nMorphological Processing\nNormalization\n### 5.3 Image Enhancement\nMedian Filtering\nBicubic Interpolation\nHistogram Equalization\nGaussian Filtering\nCore Point Detection: the Poincare index\nCropping 353*392 size\n### 5.4 Feature Extraction\nAFIS Open Source Engine\n### 5.5 Matching\nUsing AFIS Open Source Engine to get two compared fingerprints score.\n\n## 6 Results\nWe chose two group fingerprint sample. Each of them contains 30 finger images and then we compared the two group samples with corresponding database fingerprints. Through analyzing the resulting score matrix, the first group: false reject number is 8, FRR is 0.888%, false accept number is 0, FAR is 0%; the second group:  false reject number is 1, FRR is 0.111%, false accept number is 2, FAR is 0.222%\n## 7 Discussion\nThe experiment  results has been shown that fingerprint recognition on smartphones is possible. A capture process for fingerprint in combination with efficient processing algorithms was developed. The implemented algorithms ensure the suitability of the captured photos for fingerprint recognition.\n## Reference\n[1] D. Maltoni, D. Maio, A. K.Jain, and S. Prabhakar, Handbook of Fingerprint Recognition, Springer- Verlag, New York, 2003.\n[2] B.Y. Hiew, Andrew B.J. Teoh, Member, IEEE and Y.H. Pang, Digital Camera based Fingerprint Recognition, Proceedings of the 2007 IEEE International Conference on Telecommunications and Malaysia International Conference on Communications, 14-17 May 2007, Penang, Malaysia.\n[3] Rodger Jamieson, Ph.D., CA, Greg Stephens and Santhosh Kumar, Fingerprint Identification: An Aid to the Authentication Process, 2005 Information Systems Audit and Control Association.\n[4] Jainam Shah*, Ujash Poshiya, Touchless Fingerprint Reorganization, Vishwakarma Government Engineering College, Chandkheda Gujarat, India.\n[5] M. Hashimoto, S. Tanaka, and J. Thornton, \"Biometrics in Mobile Handsets\", Technical Report, Mitsubishi Electric Corporation, June 2005.\n[6] T. Nakamura, H. Fujiwara, M. Hirooka, and K. Sumi, \"Fingerprint Enhancement Using a Parallel Ridge Filter\", 17th International Conference on Pattern Recognition 2004, Cambridge, United Kingdom, 2004.\n[7] C. Lee, S. Lee, and J. Kim, \"A Study of Touchless Fingerprint Recognition System\", Joint IAPR International Workshops, SSPR 2006 and SPR 2006, Hong Kong, China, 2006.\n[8] C.H. Lee, S.H. Lee, J.H. Kim, and S.J. Kim, \"Preprocessing of a Fingerprint Image Captured with a Mobile Camera \", Advances in Biometrics: International Conference, Hong Kong, China, 2006.\n[9] G. Parziale and E. Diaz-Santana, \"The Surround Imager: A Multi-camera Touchless Device to Acquire 3D Rolled-Equivalent Fingerprints\", IAPR International Conference on Biometrics, Hong Kong, China, 2006.\n[10] Y. Chen, G. Parziale, E. Diaz-Santana, and A. Jain, \"3D Touchless Fingerprints: Compatibility with Legacy Rolled Images\", Proceeding of Biometric Symposium, Biometric Consortium Conference, Baltimore,MD, U.S.A, 2006.\n[11] Y. Song, C. Lee, and J. Kim, \"A New Scheme for Touchless Fingerprint Recognition System\", International Symposium on Intelligent Signal Processing and Communication Systems, Korea, 2004\n[12] Dileep Kumar, Yeonseung Ryu, A Brief Introduction of Biometrics and Fingerprint Payment Technology , International Journal of Advanced Science and Technology Vol. 4, March, 2009\n","slug":"thesis","published":1,"updated":"2015-07-09T09:27:57.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03geo0005n8sv13x0s650"},{"title":"Hello World","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"title: Hello World\ncategories: Guide\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2015-07-09T09:27:57.870Z","updated":"2015-07-09T09:27:57.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03ger0009n8svb4ytjt18"},{"title":"Welcome to my github page","date":"2015-06-25T10:51:40.000Z","toc":true,"_content":"## Start\n孜孜不倦的研究了几天Github Pages Service的使用，终于把博客地址从[博客园Cnblogs](http://www.cnblogs.com/Kassadin/)迁移到了这里。看到了酷炫的代码，感觉好开心！\n\n## Why\n为什么我要从cnblogs转移到github呢？\n* 最主要的原因在于，我实在不知道怎么在cnblogs上实现pretty code. 每次在cnblogs上看到别人华丽的代码，再看看我post的代码，简直惨不忍睹！于是我研究了一天怎么自定义cnblogs的博客版面，怎样实现一个好的代码显示。可是太难了！！！学不会啊！在我查找资料的过程中，偶然看到了Github Pages，点进去一看，瞬间被github的代码显示所吸引。当晚，我又对比了几大博客服务的代码显示，最终下定决定转移到github pages上，于是便有了现在你看到的这个东西！\n* 第二个原因，也是我写博客园以来一直比较郁闷的！它推荐的客户端没有Linux版本！可是我又十分想在Linux（Mac）上写博客。每次我在Linux上工作时只能在网站写，插入图片各种麻烦，总之就郁闷。\n* 第三个原因，是博客默认字体太小了，每次我都在排版上战战兢兢地调整很久，最后排版还是很差。。好伤心。可以去[My blog](http://www.cnblogs.com/Kassadin/)这里看看！\n\n总之，Github Pages满足了我视觉强迫症和代码强迫症。现在这3个问题都解决啦，感觉棒棒哒！\n\n## How\n现在这里还处于起步阶段。Github博客的撰写采用[Markdown](https://guides.github.com/features/mastering-markdown/)文法。这个文法非常的简单快捷好玩儿！我这几天已经玩儿上瘾了！导致我的毕业设计一度搁置！*（都快答辩了，泥垢QwQ）*\n\n这里的短期规划是：把毕业设计先放上去玩儿一玩儿。长期规划还没有，估计以后会整理一下VDM和需求工程的东西上来，评论系统要不要加还在考虑（不，学习。。。）当中。\n总之就这样吧。 Thank you for reading.\n\n## About\n1. Li Yi\n2. 中二病\n3. [HUST](http://www.hust.edu.cn/),[Hosei](http://www.hosei.ac.jp/),[SYSU](http://www.sysu.edu.cn/2012/cn/index.htm)\n4. [博客园](http://www.cnblogs.com/Kassadin/)\n5. Acfun/Bilibili\n6. LoL/LPL/LCK\n7. Programmer(However,什么也不会)，档案管理员(原来会maybe，现在都忘了。。)\n8. 形式化方法,需求工程, PM in academic project management\n9. Node.js\n","source":"_posts/Welcome.md","raw":"title: Welcome to my github page\ndate: 2015-06-25 19:51:40\ntags:\ncategories: Guide\ntoc: true\n---\n## Start\n孜孜不倦的研究了几天Github Pages Service的使用，终于把博客地址从[博客园Cnblogs](http://www.cnblogs.com/Kassadin/)迁移到了这里。看到了酷炫的代码，感觉好开心！\n\n## Why\n为什么我要从cnblogs转移到github呢？\n* 最主要的原因在于，我实在不知道怎么在cnblogs上实现pretty code. 每次在cnblogs上看到别人华丽的代码，再看看我post的代码，简直惨不忍睹！于是我研究了一天怎么自定义cnblogs的博客版面，怎样实现一个好的代码显示。可是太难了！！！学不会啊！在我查找资料的过程中，偶然看到了Github Pages，点进去一看，瞬间被github的代码显示所吸引。当晚，我又对比了几大博客服务的代码显示，最终下定决定转移到github pages上，于是便有了现在你看到的这个东西！\n* 第二个原因，也是我写博客园以来一直比较郁闷的！它推荐的客户端没有Linux版本！可是我又十分想在Linux（Mac）上写博客。每次我在Linux上工作时只能在网站写，插入图片各种麻烦，总之就郁闷。\n* 第三个原因，是博客默认字体太小了，每次我都在排版上战战兢兢地调整很久，最后排版还是很差。。好伤心。可以去[My blog](http://www.cnblogs.com/Kassadin/)这里看看！\n\n总之，Github Pages满足了我视觉强迫症和代码强迫症。现在这3个问题都解决啦，感觉棒棒哒！\n\n## How\n现在这里还处于起步阶段。Github博客的撰写采用[Markdown](https://guides.github.com/features/mastering-markdown/)文法。这个文法非常的简单快捷好玩儿！我这几天已经玩儿上瘾了！导致我的毕业设计一度搁置！*（都快答辩了，泥垢QwQ）*\n\n这里的短期规划是：把毕业设计先放上去玩儿一玩儿。长期规划还没有，估计以后会整理一下VDM和需求工程的东西上来，评论系统要不要加还在考虑（不，学习。。。）当中。\n总之就这样吧。 Thank you for reading.\n\n## About\n1. Li Yi\n2. 中二病\n3. [HUST](http://www.hust.edu.cn/),[Hosei](http://www.hosei.ac.jp/),[SYSU](http://www.sysu.edu.cn/2012/cn/index.htm)\n4. [博客园](http://www.cnblogs.com/Kassadin/)\n5. Acfun/Bilibili\n6. LoL/LPL/LCK\n7. Programmer(However,什么也不会)，档案管理员(原来会maybe，现在都忘了。。)\n8. 形式化方法,需求工程, PM in academic project management\n9. Node.js\n","slug":"Welcome","published":1,"updated":"2015-07-09T09:27:57.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03geu000cn8svrxhcyqmv"},{"title":"3.2 Nancy Framework","date":"2015-06-29T13:49:49.000Z","toc":true,"_content":"## 1 SOA and Web Service\n### 1.1 What is SOA\nSOA（service-oriented architecture）即面向服务的体系结构。简单来说，SOA就是一种进行系统开发的新的体系架构，在基于SOA架构的系统中，具体应用程序的功能是由一些松耦合并且具有统一接口定义方式的组件（也就是service）组合构建起来的。使用SOA架构的优势在于实现了应用系统的跨平台性和可扩展性。\n\n以我们的指纹认证系统举例，现在我们要实现一个Android手机客户端和一个服务器端，Android客户端通过与服务器端通信调用服务器端提供的API，以实现指纹上传，指纹认证等功能。在传统软件架构模式下，客户端和服务器端开发应处于同一个技术架构当中，比如客户端采用Android（Java），服务器端采用Java EE；或者客户端采用Windows Phone，服务器端采用.net Framework.这种软件架构模式是一种紧耦合的体系结构。其优点在于软件模块紧密协作，调用相同的底层模块，然而这种模式的缺点也十分明显：最大的问题是扩展性差的问题。比如.net开发的服务程序要求客户端同样采用.net技术，这种技术架构已不能满足移动互联网发展的需要。\n\n在移动互联网时代，一项服务往往要为多种客户端提供支持，比如社交软件Line的登录服务，既要为PC客户端提供支持，又要为Android应用提供支持，同时也需要提供iOS的服务支持，甚至还要提供浏览器的相关支持；如果采用传统的体系结构，每添加一个平台都要重写相应的服务，而这些服务所提供的功能几乎是一模一样的，这显示不符合DRY（Don‘t Repeat Yourself）的软件工程原则。在这样的背景下，SOA架构便迅速发展起来。\n\n在SOA架构下，服务器端的每个应用功能都被封装成服务，而这些服务都是平台无关的。客户端与服务器端通过消息传递的方式进行通信，客户端需要调用服务器功能时，直接面向服务接口发送消息，这样就实现了从面向具体技术的体系结构向面向服务的体系结构的转变。无论客户端采用Android技术，还是iOS技术，还是浏览器，抑或是PC客户端，它们都同一调用相同的服务，服务器端不需要做任何改变即可支持多种平台的扩展。这种面向服务的编程模式极大的加强了应用架构的跨平台行和可扩展性，逐渐成为移动互联网时代最主流的架构模式。Web Service是实现SOA最为基础的一项技术之一。\n![SOA](/images/thesis/chapter3/2.bmp)\n### 1.2 Web Service\nWeb Service是实现SOA最常用的技术之一。它通过标准的Web协议提供服务，目的是保证不同平台的应用服务可以互操作。（[Web Service](https://en.wikipedia.org/wiki/Web_service)）\n\nWeb Service技术经过多年发展，目前出现了两大主要的类型：\n1. 基于SOAP的Web Service\n2. 基于REST的Web Service\n\n基于SOAP的Web Service：SOAP用来描述传递信息的格式， WSDL用来描述如何访问具体的接口，UDDI用来管理，分发，查询Web Service。SOAP采用了已经广泛使用的两个协议:HTTP和XML（标准通用标记语言下的一个子集）。HTTP用于实现SOAP的RPC风格的传输, 而XML是它的编码模式。使用SOAP，使得Web Service具备了良好的可扩展性，完全与厂商无关，与编程语言无关，与平台无关。\n\n基于REST的Web Service：RT Fielding博士的博士论文《Architectural Styles and the Design of Network-based Software Architectures》奠定了REST风格Web Service的基础。REST 是英文 Representational State Transfer 的缩写。它具有如下特征：\n1. 首先REST只是一种风格，不是一种标准\n2. REST是以资源为中心的\n3. REST的目的是决定如何使一个定义良好的Web程序向前推进\n4. REST充分利用或者说极端依赖HTTP协议：\n* 它通过逻辑URI定位资源\n* 通过分辨 HTTP Request Header 信息来分辨客户端是想要取得资源的哪一种表现形式的数据。\n* 在 REST 架构中，用不同的 HTTP 请求方法来处理对资源的 CRUD（创建、读取、更新和删除）操作\n\n![REST API](/images/thesis/chapter3/3.bmp)\nREST风格的这些特点，使它比SOAP更加轻量，更充分利用HTTP协议，甚至可以说REST真正表达了HTTP协议的设计原本，REST的出现彻底改变了Web Service的现状，适应了移动互联网的发展趋势，现在主流的移动客户端开发基本都转向了REST风格的Web Service.为了实现Android端的指纹识别客户端，本系统也采用了REST风格的Web Service.\n## 2 MVC and Nancy Framework\n本系统采用Nancy Framework实现了一个轻量级的REST风格的Web Service。Nancy Framework是基于.net和mono平台的超轻量级Web框架，它遵循MVC框架模式，并设计用来提供REST风格的Web服务。其[官方网站](http://nancyfx.org/)介绍了Nancy具有如下特点：\n1. Nancy is a lightweight, low-ceremony, framework for building HTTP based services on .Net and Mono. The goal of the framework is to stay out of the way as much as possible and provide a super-duper-happy-path to all interactions.\n2. Nancy is designed to handle DELETE, GET, HEAD, OPTIONS, POST, PUT and PATCH requests and provides a simple, elegant, Domain Specific Language (DSL) for returning a response with just a couple of keystrokes.\n3. Nancy is built to run anywhere.\n\n## 2.1 MVC框架模式\nNancy Framework的设计思想来源于Ruby的Sinatra Framework，其基本思想在于MVC框架模式。MVC模式即Model－View－Controller模式，其中：\n* Model表示模型，是应用程序中处理应用程序数据逻辑的部分。通常用来封装数据对象存储数据。\n* View表示视图，是应用程序中处理数据显示的部分。通常视图数据需要从模型获取。\n* Controller表示控制器，控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\n\n![MVC](/images/thesis/chapter3/4.bmp)\n上图展示了MVC模式基本工作原理：\n1. 首先，用户向应用程序发出请求，等待服务器响应\n2. controller接收用户请求，控制器根据请求内容决定分发给哪个model或view处理\n3. controller向model请求数据\n4. model从database获取数据，并将数据返回给controller\n5. controller将model获取的数据发送给相应view\n6. view根据model数据填充视图，并将结果返回给controller\n7. controller将view返回给用户。\n\n通过MVC框架模式，实现了应用程序业务逻辑和表现的分离，降低了模块之间的耦合性，现在越来越多的应用系统均采用MVC模式，许多框架也都遵循MVC模式，比如Ruby on Rails，Java Spring MVC，ASP.net MVC等等。本系统采用的Nancy Framework也是.net上一个超轻量级的MVC框架。\n## 2.2 Nancy架构思想\nNancy Framework是.net平台上一个基于MVC模式的超轻量级Web框架，Nancy Project的项目结构如下图所示：\n![Nancy](/images/thesis/chapter3/5.png)\nNancy Framework中Model，Module，Views分别代表了M，V，C。\n1. 控制器采用REST风格，其基本模式如下：当用户在浏览器输入http://hostaddress/，Nancy Framework的控制器类会首先根据uri地址匹配相应的controller.这种机制被称为Route机制，是Nancy Framework实现REST风格控制器的核心。当用户以GET方式请求根目录资源时，控制器会根据Route机制查找GET[\"/\"]的控制器，匹配成功以后，由该控制器处理用户请求。控制器可以调用相应的View资源和Model资源最终响应用户请求。\n``` csharp\nGet[\"/\"] = parameters =>\n{\n    return View[\"index\"];\n};\n```\n2. 视图以HTML为基本风格，在Nancy官方支持的视图引擎为Radar引擎，其语法大致与HTML相似。\n``` html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Fingerprint Web Service Page</title>\n</head>\n<body>\n    Content\n</body>\n</html>\n```\n3. 模型一般以Database为模版映射为对象，支持大多ORM框架。\n\n## 3 A System Instance\n指纹识别系统的系统详细架构图如下所示：\n![System Architecture](/images/thesis/chapter3/6.bmp)\n","source":"_posts/Nancy-Framework.md","raw":"title: 3.2 Nancy Framework\ndate: 2015-06-29 22:49:49\ncategories: Thesis\ntags: thesis\ntoc: true\n---\n## 1 SOA and Web Service\n### 1.1 What is SOA\nSOA（service-oriented architecture）即面向服务的体系结构。简单来说，SOA就是一种进行系统开发的新的体系架构，在基于SOA架构的系统中，具体应用程序的功能是由一些松耦合并且具有统一接口定义方式的组件（也就是service）组合构建起来的。使用SOA架构的优势在于实现了应用系统的跨平台性和可扩展性。\n\n以我们的指纹认证系统举例，现在我们要实现一个Android手机客户端和一个服务器端，Android客户端通过与服务器端通信调用服务器端提供的API，以实现指纹上传，指纹认证等功能。在传统软件架构模式下，客户端和服务器端开发应处于同一个技术架构当中，比如客户端采用Android（Java），服务器端采用Java EE；或者客户端采用Windows Phone，服务器端采用.net Framework.这种软件架构模式是一种紧耦合的体系结构。其优点在于软件模块紧密协作，调用相同的底层模块，然而这种模式的缺点也十分明显：最大的问题是扩展性差的问题。比如.net开发的服务程序要求客户端同样采用.net技术，这种技术架构已不能满足移动互联网发展的需要。\n\n在移动互联网时代，一项服务往往要为多种客户端提供支持，比如社交软件Line的登录服务，既要为PC客户端提供支持，又要为Android应用提供支持，同时也需要提供iOS的服务支持，甚至还要提供浏览器的相关支持；如果采用传统的体系结构，每添加一个平台都要重写相应的服务，而这些服务所提供的功能几乎是一模一样的，这显示不符合DRY（Don‘t Repeat Yourself）的软件工程原则。在这样的背景下，SOA架构便迅速发展起来。\n\n在SOA架构下，服务器端的每个应用功能都被封装成服务，而这些服务都是平台无关的。客户端与服务器端通过消息传递的方式进行通信，客户端需要调用服务器功能时，直接面向服务接口发送消息，这样就实现了从面向具体技术的体系结构向面向服务的体系结构的转变。无论客户端采用Android技术，还是iOS技术，还是浏览器，抑或是PC客户端，它们都同一调用相同的服务，服务器端不需要做任何改变即可支持多种平台的扩展。这种面向服务的编程模式极大的加强了应用架构的跨平台行和可扩展性，逐渐成为移动互联网时代最主流的架构模式。Web Service是实现SOA最为基础的一项技术之一。\n![SOA](/images/thesis/chapter3/2.bmp)\n### 1.2 Web Service\nWeb Service是实现SOA最常用的技术之一。它通过标准的Web协议提供服务，目的是保证不同平台的应用服务可以互操作。（[Web Service](https://en.wikipedia.org/wiki/Web_service)）\n\nWeb Service技术经过多年发展，目前出现了两大主要的类型：\n1. 基于SOAP的Web Service\n2. 基于REST的Web Service\n\n基于SOAP的Web Service：SOAP用来描述传递信息的格式， WSDL用来描述如何访问具体的接口，UDDI用来管理，分发，查询Web Service。SOAP采用了已经广泛使用的两个协议:HTTP和XML（标准通用标记语言下的一个子集）。HTTP用于实现SOAP的RPC风格的传输, 而XML是它的编码模式。使用SOAP，使得Web Service具备了良好的可扩展性，完全与厂商无关，与编程语言无关，与平台无关。\n\n基于REST的Web Service：RT Fielding博士的博士论文《Architectural Styles and the Design of Network-based Software Architectures》奠定了REST风格Web Service的基础。REST 是英文 Representational State Transfer 的缩写。它具有如下特征：\n1. 首先REST只是一种风格，不是一种标准\n2. REST是以资源为中心的\n3. REST的目的是决定如何使一个定义良好的Web程序向前推进\n4. REST充分利用或者说极端依赖HTTP协议：\n* 它通过逻辑URI定位资源\n* 通过分辨 HTTP Request Header 信息来分辨客户端是想要取得资源的哪一种表现形式的数据。\n* 在 REST 架构中，用不同的 HTTP 请求方法来处理对资源的 CRUD（创建、读取、更新和删除）操作\n\n![REST API](/images/thesis/chapter3/3.bmp)\nREST风格的这些特点，使它比SOAP更加轻量，更充分利用HTTP协议，甚至可以说REST真正表达了HTTP协议的设计原本，REST的出现彻底改变了Web Service的现状，适应了移动互联网的发展趋势，现在主流的移动客户端开发基本都转向了REST风格的Web Service.为了实现Android端的指纹识别客户端，本系统也采用了REST风格的Web Service.\n## 2 MVC and Nancy Framework\n本系统采用Nancy Framework实现了一个轻量级的REST风格的Web Service。Nancy Framework是基于.net和mono平台的超轻量级Web框架，它遵循MVC框架模式，并设计用来提供REST风格的Web服务。其[官方网站](http://nancyfx.org/)介绍了Nancy具有如下特点：\n1. Nancy is a lightweight, low-ceremony, framework for building HTTP based services on .Net and Mono. The goal of the framework is to stay out of the way as much as possible and provide a super-duper-happy-path to all interactions.\n2. Nancy is designed to handle DELETE, GET, HEAD, OPTIONS, POST, PUT and PATCH requests and provides a simple, elegant, Domain Specific Language (DSL) for returning a response with just a couple of keystrokes.\n3. Nancy is built to run anywhere.\n\n## 2.1 MVC框架模式\nNancy Framework的设计思想来源于Ruby的Sinatra Framework，其基本思想在于MVC框架模式。MVC模式即Model－View－Controller模式，其中：\n* Model表示模型，是应用程序中处理应用程序数据逻辑的部分。通常用来封装数据对象存储数据。\n* View表示视图，是应用程序中处理数据显示的部分。通常视图数据需要从模型获取。\n* Controller表示控制器，控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\n\n![MVC](/images/thesis/chapter3/4.bmp)\n上图展示了MVC模式基本工作原理：\n1. 首先，用户向应用程序发出请求，等待服务器响应\n2. controller接收用户请求，控制器根据请求内容决定分发给哪个model或view处理\n3. controller向model请求数据\n4. model从database获取数据，并将数据返回给controller\n5. controller将model获取的数据发送给相应view\n6. view根据model数据填充视图，并将结果返回给controller\n7. controller将view返回给用户。\n\n通过MVC框架模式，实现了应用程序业务逻辑和表现的分离，降低了模块之间的耦合性，现在越来越多的应用系统均采用MVC模式，许多框架也都遵循MVC模式，比如Ruby on Rails，Java Spring MVC，ASP.net MVC等等。本系统采用的Nancy Framework也是.net上一个超轻量级的MVC框架。\n## 2.2 Nancy架构思想\nNancy Framework是.net平台上一个基于MVC模式的超轻量级Web框架，Nancy Project的项目结构如下图所示：\n![Nancy](/images/thesis/chapter3/5.png)\nNancy Framework中Model，Module，Views分别代表了M，V，C。\n1. 控制器采用REST风格，其基本模式如下：当用户在浏览器输入http://hostaddress/，Nancy Framework的控制器类会首先根据uri地址匹配相应的controller.这种机制被称为Route机制，是Nancy Framework实现REST风格控制器的核心。当用户以GET方式请求根目录资源时，控制器会根据Route机制查找GET[\"/\"]的控制器，匹配成功以后，由该控制器处理用户请求。控制器可以调用相应的View资源和Model资源最终响应用户请求。\n``` csharp\nGet[\"/\"] = parameters =>\n{\n    return View[\"index\"];\n};\n```\n2. 视图以HTML为基本风格，在Nancy官方支持的视图引擎为Radar引擎，其语法大致与HTML相似。\n``` html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Fingerprint Web Service Page</title>\n</head>\n<body>\n    Content\n</body>\n</html>\n```\n3. 模型一般以Database为模版映射为对象，支持大多ORM框架。\n\n## 3 A System Instance\n指纹识别系统的系统详细架构图如下所示：\n![System Architecture](/images/thesis/chapter3/6.bmp)\n","slug":"Nancy-Framework","published":1,"updated":"2015-07-09T09:27:57.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03gew000en8sv354n15wc"},{"title":"CodeTest","date":"2015-06-20T10:08:56.000Z","toc":true,"_content":"参考文献：[Hexo在github上构建免费的Web应用](http://blog.fens.me/hexo-blog-github/)\n## Javascript\n```javascript\nvar mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost/test');\n\nvar Cat = mongoose.model('Cat',{\n\tname: String,\n\tfriends: [String],\n\tage: Number,\n});\n\nvar kitty = new Cat({name: 'Zildjian', friends: ['tom','jerry']});\nkitty.age = 3;\n\nkitty.save(function(err) {\n\tif(err) ;\n\tconsole.log('meow');\n});\n```\n## Java\n``` java\nimport javax.jws.WebMethod;\nimport javax.jws.WebService;\n/*\n * SEI;\n */\n@WebService\npublic interface HelloWS {\n\n\t@WebMethod\n\tpublic String sayHello(String name);\n}\n```\n## Ruby\n```ruby\n@numtocodetable = Hash.[](\n  \"21\" => \"q\",  \"22\" => \"w\",  \"23\" => \"e\",  \"31\" => \"r\",  \"32\" => \"t\",  \"33\" => \"y\",\n  \"41\" => \"u\",  \"42\" => \"i\",  \"43\" => \"o\",  \"51\" => \"p\",  \"52\" => \"a\",  \"53\" => \"s\",\n  \"61\" => \"d\",  \"62\" => \"f\",  \"63\" => \"g\",  \"71\" => \"h\",  \"72\" => \"j\",  \"73\" => \"k\",\n  \"74\" => \"l\",  \"81\" => \"z\",  \"82\" => \"x\",  \"83\" => \"c\",  \"91\" => \"v\",  \"92\" => \"b\",\n  \"93\" => \"n\",  \"94\" => \"m\"\n)\n\n  @codetonumtable = Hash.[](\n  \"q\" => \"21\", \"w\" => \"22\", \"e\" => \"23\", \"r\" => \"31\", \"t\" => \"32\", \"y\" => \"33\",\n  \"u\" => \"41\", \"i\" => \"42\", \"o\" => \"43\", \"p\" => \"51\", \"a\" => \"52\", \"s\" => \"53\",\n  \"d\" => \"61\", \"f\" => \"62\", \"g\" => \"63\", \"h\" => \"71\", \"j\" => \"72\", \"k\" => \"73\",\n  \"l\" => \"74\", \"z\" => \"81\", \"x\" => \"82\", \"c\" => \"83\", \"v\" => \"91\", \"b\" => \"92\",\n  \"n\" => \"93\", \"m\" => \"94\"\n)\n\ndef self.codetonum(code)\n    num = \"\"\n    codeinput = code\n    codeinput.split(//).each do |item|\n      num = num + @codetonumtable[item]\n    end\n    return num\nend\n\ndef self.numtocode(num)\n    p = \"\"\n    input = num\n    str = input.scan(/[0-9]{2}/)\n    str.each do |item|\n      p = p + @numtocodetable[item]\n    end\n    return p\nend\n```\n## Python\n```python\nprint('hello world')\n```\n\n## CSharp\n``` csharp\nusing System;\n\nnamespace HelloWorld\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tConsole.WriteLine (\"Hello World!\");\n\t\t}\n\t}\n}\n```\n","source":"_posts/CodeTest.md","raw":"title: CodeTest\ndate: 2015-06-20 19:08:56\ncategories: Javascript\ntags: thesis\ntoc: true\n---\n参考文献：[Hexo在github上构建免费的Web应用](http://blog.fens.me/hexo-blog-github/)\n## Javascript\n```javascript\nvar mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost/test');\n\nvar Cat = mongoose.model('Cat',{\n\tname: String,\n\tfriends: [String],\n\tage: Number,\n});\n\nvar kitty = new Cat({name: 'Zildjian', friends: ['tom','jerry']});\nkitty.age = 3;\n\nkitty.save(function(err) {\n\tif(err) ;\n\tconsole.log('meow');\n});\n```\n## Java\n``` java\nimport javax.jws.WebMethod;\nimport javax.jws.WebService;\n/*\n * SEI;\n */\n@WebService\npublic interface HelloWS {\n\n\t@WebMethod\n\tpublic String sayHello(String name);\n}\n```\n## Ruby\n```ruby\n@numtocodetable = Hash.[](\n  \"21\" => \"q\",  \"22\" => \"w\",  \"23\" => \"e\",  \"31\" => \"r\",  \"32\" => \"t\",  \"33\" => \"y\",\n  \"41\" => \"u\",  \"42\" => \"i\",  \"43\" => \"o\",  \"51\" => \"p\",  \"52\" => \"a\",  \"53\" => \"s\",\n  \"61\" => \"d\",  \"62\" => \"f\",  \"63\" => \"g\",  \"71\" => \"h\",  \"72\" => \"j\",  \"73\" => \"k\",\n  \"74\" => \"l\",  \"81\" => \"z\",  \"82\" => \"x\",  \"83\" => \"c\",  \"91\" => \"v\",  \"92\" => \"b\",\n  \"93\" => \"n\",  \"94\" => \"m\"\n)\n\n  @codetonumtable = Hash.[](\n  \"q\" => \"21\", \"w\" => \"22\", \"e\" => \"23\", \"r\" => \"31\", \"t\" => \"32\", \"y\" => \"33\",\n  \"u\" => \"41\", \"i\" => \"42\", \"o\" => \"43\", \"p\" => \"51\", \"a\" => \"52\", \"s\" => \"53\",\n  \"d\" => \"61\", \"f\" => \"62\", \"g\" => \"63\", \"h\" => \"71\", \"j\" => \"72\", \"k\" => \"73\",\n  \"l\" => \"74\", \"z\" => \"81\", \"x\" => \"82\", \"c\" => \"83\", \"v\" => \"91\", \"b\" => \"92\",\n  \"n\" => \"93\", \"m\" => \"94\"\n)\n\ndef self.codetonum(code)\n    num = \"\"\n    codeinput = code\n    codeinput.split(//).each do |item|\n      num = num + @codetonumtable[item]\n    end\n    return num\nend\n\ndef self.numtocode(num)\n    p = \"\"\n    input = num\n    str = input.scan(/[0-9]{2}/)\n    str.each do |item|\n      p = p + @numtocodetable[item]\n    end\n    return p\nend\n```\n## Python\n```python\nprint('hello world')\n```\n\n## CSharp\n``` csharp\nusing System;\n\nnamespace HelloWorld\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tConsole.WriteLine (\"Hello World!\");\n\t\t}\n\t}\n}\n```\n","slug":"CodeTest","published":1,"updated":"2015-07-09T09:27:57.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03gey000in8svdo5tchz4"},{"title":"4.4 Algorithm","date":"2015-06-25T13:49:44.000Z","_content":"## Display Matrix\nSuppose the QR Code image matrix is：\n\n$Q=\\begin{bmatrix}\n255 & 254 & 255 & 1 & 2 & \\cdots\\\\\\\n255 & 255 & 255 & 1 & 1 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nIts binary form is：\n\n$Q=\\begin{bmatrix}\n111111\\color{red}{11} & 111111\\color{red}{10} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{10} & \\cdots\\\\\\\n111111\\color{red}{11} & 111111\\color{red}{11} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{01} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nThe watermark image matrix is:\n\n$M=\\begin{bmatrix}\n167 & 63 & 15 & \\cdots\\\\\\\n255 & 127 & 128 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nIts binary form is:\n\n$M=\\begin{bmatrix}\n10100111 & 00111111 & 00001111 & \\cdots\\\\\\\n11111111 & 01111111 & 10000000 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nNow we will separate the watermark matrix to encode it to the QRcode matrix.\nLet's focus the watermark matrix first.\n## Watermark Matrix\nFor the watermark matrix above, we called it M, we can see M(1,1)=167, in binary form, M(1,1)=10100111. We separate it to 4 parts.\n\n<strong><font color=\"red\" size=\"6\">10</font></strong><strong><font color=\"green\" size=\"6\">10</font></strong><strong><font color=\"blue\" size=\"6\">01</font></strong><strong><font color=\"yellow\" size=\"6\">11</font></strong>\n\n1. The Red Part: the 1-2 bit\n2. The Green Part: the 3-4 bit\n3. The Blue Part: the 5-6 bit\n4. The Yellow Part: the 7-8 bit\n\nThen we can get 4 matrix from 4 parts:\n1.The Red Part Matrix is:\n\n$M1=\\begin{bmatrix}\n10 & 00 & 00 & \\cdots\\\\\\\n11 & 01 & 10 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 0 & 0 & \\cdots\\\\\\\n3 & 1 & 2 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n2.The Green Part Matrix is:\n\n$M2=\\begin{bmatrix}\n10 & 11 & 00 & \\cdots\\\\\\\n11 & 11 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 3 & 0 & \\cdots\\\\\\\n3 & 3 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n3.The Blue Part Matrix is:\n\n$M3=\\begin{bmatrix}\n01 & 11 & 11 & \\cdots\\\\\\\n11 & 01 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n1 & 3 & 3 & \\cdots\\\\\\\n3 & 1 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n4.The Yellow Part Matrix is:\n\n$M4=\\begin{bmatrix}\n11 & 11 & 11 & \\cdots\\\\\\\n11 & 11 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n3 & 3 & 3 & \\cdots\\\\\\\n3 & 3 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n## Encoding Method\n### Why we can encode QRCode Image with watermark image?\nThe QRCode Image is bigger than watermark image. The rows of QRCode image is 3 times higher than watermark image; the colmns is 5 times higher than watermark image. So we can embed the watermark matrix into qrcode matrix. It is very important. In our method, the watermark matrix M is a 392\\*357 matrix; the qrcode matrix Q is a 900\\*5000 matrix.\n\nIn addition, the QRCode image and watermark image are both grayscale images.\n### How to encode?\nWe use Least Significant Bit Algorithm. First, we separate matrix Q to 5 parts.\n\n$Q=\\begin{bmatrix}\nA&B& \\\\\\\nC&D& \\\\\\\n & &E\n\\end{bmatrix}$\n\nFor matrix A,B,C,D, they are all 392\\*357 matrix. E is the rest part of Q.\nThen we use A,B,C,D and M1,M2,M3,M4 to encode. We set the least 2 bits of A,B,C,D to 0. For example:\n\n$A=\\begin{bmatrix}\n111111\\color{red}{11} & 111111\\color{red}{10} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{10} & \\cdots\\\\\\\n111111\\color{red}{11} & 111111\\color{red}{11} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{01} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nset the least 2 bits to 0:\n\n$A1=\\begin{bmatrix}\n111111\\color{red}{00} & 111111\\color{red}{00} & 111111\\color{red}{00} & 000000\\color{red}{00} & 000000\\color{red}{00} & \\cdots\\\\\\\n111111\\color{red}{00} & 111111\\color{red}{00} & 111111\\color{red}{00} & 000000\\color{red}{00} & 000000\\color{red}{00} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nthen we use matrix M1 instead of the least 2 bits of A:\n```python\nA2 = A1 + M1\n```\nFor B,C,D and M2,M3,M4 ,we do the some operation:\n```python\nB2 = B1 + M2\nC2 = C1 + M3\nD2 = D1 + M4\n```\nAfter that, we will get a new matrix called Q2:\n\n$Q2=\\begin{bmatrix}\nA2&B2& \\\\\\\nC2&D2& \\\\\\\n & &E\n\\end{bmatrix}$\n\nThe matrix Q2 contains all the information of watermark images. Now we have realized Encoding Module.\n\n## Decoding Method\nIt is easy to get the watermark matrix. From Q2 we can extract A2,B2,C2,D2, then we will get M1,M2,M3,M4 by mod([A2,B2,C2,D2],4).\n```python\nM1(i,j) = A2(i,j) mod 4\nM2(i,j) = B2(i,j) mod 4\nM3(i,j) = C2(i,j) mod 4\nM4(i,j) = D2(i,j) mod 4\n```\nFrom M1, M2, M3, M4, we will recover watermark matrix easily.\n```python\nM(i,j)=M4(i,j)＋4 * M3(i,j)＋16 * M2(i,j)＋64 * M1(i,j)\n```\nIn this way, now we have already recover the watermark matrix.\n","source":"_posts/Algorithm.md","raw":"title: 4.4 Algorithm\ndate: 2015-06-25 22:49:44\ntags:\ncategories: Thesis\n---\n## Display Matrix\nSuppose the QR Code image matrix is：\n\n$Q=\\begin{bmatrix}\n255 & 254 & 255 & 1 & 2 & \\cdots\\\\\\\n255 & 255 & 255 & 1 & 1 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nIts binary form is：\n\n$Q=\\begin{bmatrix}\n111111\\color{red}{11} & 111111\\color{red}{10} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{10} & \\cdots\\\\\\\n111111\\color{red}{11} & 111111\\color{red}{11} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{01} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nThe watermark image matrix is:\n\n$M=\\begin{bmatrix}\n167 & 63 & 15 & \\cdots\\\\\\\n255 & 127 & 128 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nIts binary form is:\n\n$M=\\begin{bmatrix}\n10100111 & 00111111 & 00001111 & \\cdots\\\\\\\n11111111 & 01111111 & 10000000 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nNow we will separate the watermark matrix to encode it to the QRcode matrix.\nLet's focus the watermark matrix first.\n## Watermark Matrix\nFor the watermark matrix above, we called it M, we can see M(1,1)=167, in binary form, M(1,1)=10100111. We separate it to 4 parts.\n\n<strong><font color=\"red\" size=\"6\">10</font></strong><strong><font color=\"green\" size=\"6\">10</font></strong><strong><font color=\"blue\" size=\"6\">01</font></strong><strong><font color=\"yellow\" size=\"6\">11</font></strong>\n\n1. The Red Part: the 1-2 bit\n2. The Green Part: the 3-4 bit\n3. The Blue Part: the 5-6 bit\n4. The Yellow Part: the 7-8 bit\n\nThen we can get 4 matrix from 4 parts:\n1.The Red Part Matrix is:\n\n$M1=\\begin{bmatrix}\n10 & 00 & 00 & \\cdots\\\\\\\n11 & 01 & 10 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 0 & 0 & \\cdots\\\\\\\n3 & 1 & 2 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n2.The Green Part Matrix is:\n\n$M2=\\begin{bmatrix}\n10 & 11 & 00 & \\cdots\\\\\\\n11 & 11 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 3 & 0 & \\cdots\\\\\\\n3 & 3 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n3.The Blue Part Matrix is:\n\n$M3=\\begin{bmatrix}\n01 & 11 & 11 & \\cdots\\\\\\\n11 & 01 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n1 & 3 & 3 & \\cdots\\\\\\\n3 & 1 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n4.The Yellow Part Matrix is:\n\n$M4=\\begin{bmatrix}\n11 & 11 & 11 & \\cdots\\\\\\\n11 & 11 & 00 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}=\\begin{bmatrix}\n3 & 3 & 3 & \\cdots\\\\\\\n3 & 3 & 0 & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\n## Encoding Method\n### Why we can encode QRCode Image with watermark image?\nThe QRCode Image is bigger than watermark image. The rows of QRCode image is 3 times higher than watermark image; the colmns is 5 times higher than watermark image. So we can embed the watermark matrix into qrcode matrix. It is very important. In our method, the watermark matrix M is a 392\\*357 matrix; the qrcode matrix Q is a 900\\*5000 matrix.\n\nIn addition, the QRCode image and watermark image are both grayscale images.\n### How to encode?\nWe use Least Significant Bit Algorithm. First, we separate matrix Q to 5 parts.\n\n$Q=\\begin{bmatrix}\nA&B& \\\\\\\nC&D& \\\\\\\n & &E\n\\end{bmatrix}$\n\nFor matrix A,B,C,D, they are all 392\\*357 matrix. E is the rest part of Q.\nThen we use A,B,C,D and M1,M2,M3,M4 to encode. We set the least 2 bits of A,B,C,D to 0. For example:\n\n$A=\\begin{bmatrix}\n111111\\color{red}{11} & 111111\\color{red}{10} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{10} & \\cdots\\\\\\\n111111\\color{red}{11} & 111111\\color{red}{11} & 111111\\color{red}{11} & 000000\\color{red}{01} & 000000\\color{red}{01} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nset the least 2 bits to 0:\n\n$A1=\\begin{bmatrix}\n111111\\color{red}{00} & 111111\\color{red}{00} & 111111\\color{red}{00} & 000000\\color{red}{00} & 000000\\color{red}{00} & \\cdots\\\\\\\n111111\\color{red}{00} & 111111\\color{red}{00} & 111111\\color{red}{00} & 000000\\color{red}{00} & 000000\\color{red}{00} & \\cdots\\\\\\\n\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & \\cdots\n\\end{bmatrix}$\n\nthen we use matrix M1 instead of the least 2 bits of A:\n```python\nA2 = A1 + M1\n```\nFor B,C,D and M2,M3,M4 ,we do the some operation:\n```python\nB2 = B1 + M2\nC2 = C1 + M3\nD2 = D1 + M4\n```\nAfter that, we will get a new matrix called Q2:\n\n$Q2=\\begin{bmatrix}\nA2&B2& \\\\\\\nC2&D2& \\\\\\\n & &E\n\\end{bmatrix}$\n\nThe matrix Q2 contains all the information of watermark images. Now we have realized Encoding Module.\n\n## Decoding Method\nIt is easy to get the watermark matrix. From Q2 we can extract A2,B2,C2,D2, then we will get M1,M2,M3,M4 by mod([A2,B2,C2,D2],4).\n```python\nM1(i,j) = A2(i,j) mod 4\nM2(i,j) = B2(i,j) mod 4\nM3(i,j) = C2(i,j) mod 4\nM4(i,j) = D2(i,j) mod 4\n```\nFrom M1, M2, M3, M4, we will recover watermark matrix easily.\n```python\nM(i,j)=M4(i,j)＋4 * M3(i,j)＋16 * M2(i,j)＋64 * M1(i,j)\n```\nIn this way, now we have already recover the watermark matrix.\n","slug":"Algorithm","published":1,"updated":"2015-07-09T09:27:57.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03gf1000mn8svduakqbxs"},{"title":"4. Security Strategy","date":"2015-06-24T09:19:43.000Z","toc":true,"_content":"# Chapter 4 Security Strategy\nThis chapter discuss the security strategy in the fingerprint authentication system. First, we will talk about security threat briefly; Second, we discuss the traditional approach to enhance security; Third, we give a fingerprint watermark approach to solve the security problems. We will discuss reversible watermarking technology in this part.\n## 4.1 Security Threat and Common Approach\n### 4.1.1 Security Threat\nAs we have talked in chapter 1, there are some types of internet attack. One is to **intercept information**. The purpose of intercepting information is to steal data content itself. Another one is to **replay attack**. Replay attack is a form of network attack in which a valid data transmission is maliciously or fraudulently repeated or delayed. In our system, attackers will try to intercept user’s packages which contain fingerprint images. This is a kind of intercept attack. In this case, user information will be leaked. In addition, the attackers intercept data packages then they can resend these data packages to the server regardless of whether the data is encrypted. This is a kind of replay attack. Attackers use replay attack to realize the purpose of spoofing server. Then the server will consider the attacker to be the original user.\n\nThe fingerprint authentication system should be security. We try to design some security subsystem to enhance the system security. Then the system should be prevent information interception and replay attack.\n### 4.1.2 Common Approach\nFile encryption and digital signature is a common approach to enhance system security.\n* File encryption : Prevent information leaks.\n* Digital signature : Ensure the message sent by the original sender.\n\nFile encryption： The basic process flow of file encryption is to encode the original file by an algorithm, making it unreadable(commonly referred to as “ciphertext”). The original file cannot be displayed without **key**. By this way we can prevent data from being illegally stolen. The reverse process is called decryption. such as: [Algorithm 1](http://blog.csdn.net/stpeace/article/details/8315772) and [Algorithm 2](http://wenku.baidu.com/link?url=Szecji7gvHr35DDq2ltqNqa4aYdajxnfNinz8WA3_4WWVXKHgj6IFUvjTgY_V-w9eqcz4YppASDBfejSm0cIMGMZA62YlXNME9e2ZfxwVoK)\n\nDigital signature: A digital signature is a mathematical technique used to validate the authenticity and integrity of a message, software or digital document. see [searchsecurity](http://searchsecurity.techtarget.com/definition/digital-signature). The basic flow of digital signature is like this:\n![figure 1](/images/thesis/1.png)\nFrom this diagram, we can know how digital-signature works. First, the data sender uses his private key to encode the information he prepared to send, then he gets a signed message. Second, he send the signed message to the receiver. The receiver gets the signed message and decodes the message by the sender’s public key. Then the receiver gets the decrypted hash. If the decrypted hash matches a second computed hash of the same data, it proves that the data hasn’t changed since it was signed. Otherwise, it proves that the data has been changed by attackers since it was signed.\n### 4.1.3 New Approach\nThe traditional approach is good enough to enhance system security and prevent internet attack. However, there are still some disadvantages to apply it to our fingerprint system.\n1. **Complex**. Digital-signature need to be controlled in a complex architecture. Besides, we need to build two separate subsystems, one is for file encryption, the other one is for digital signature. It will be more complex.\n2. **Common Approach**. It is a common approach to enhance system security. It does not take into account the characteristics of the fingerprint image.\n\nIn order to overcome the two drawbacks, we try to propose a new approach. The new approach is a kind of reversible digital watermark technology and it combine file encryption with authentication. We will discuss the detail in 4.3 Solution and 4.4 Algorithm.\n\n## 4.2 Architecture\n\nWaiting to write ...\n\n## 4.3 Solution\n\nWaiting to write ...\n\n## 4.4 Algorithm\n\nWaiting to write ...\n\n### Step1: Read and display\nDisplay the QrCode image and fingerprint image. use fingerprint image as watermark.\n```matlab\nclear;\nclc;\n\n%= Read the QRCode and FP watermarkImage\nqrImage = imread('qrImage.png');\nfpImage = imread('watermarkImage.bmp');\nwatermarkImage = double(fpImage);\n\nfigure;\nimshow(qrImage);\ntitle('the qrCode Image!');\n\nfigure;\nimshow(uint8(watermarkImage));\ntitle('the image with water marks!');\n```\nThen the QR Code Image and fingerprint image are displayed.\n![figure 2](/images/thesis/2.jpg)\n![figure 3](/images/thesis/3.jpg)\n### Step2: Encoding\nUse the algorithm below to encode the QRcode with fingerprint image.\n```matlab\n[m,n] = size(watermarkImage);\nnewwatermark=zeros(m,n);\nnewwatermark2 = zeros(m,n);\nmultiwatermarkImage = zeros(2*m,2*n);\norimod = zeros(2*m,2*n);\n\nqrImage1 = qrImage;\nqrImage2 = qrImage;\n\nfor i=1:m\n  for j=1:n\n    orimod(i,j)=mod(qrImage(i,j,1),4);\n    orimod(i+m,j) = mod(qrImage(i+m,j,1),4);\n    orimod(i,j+n) = mod(qrImage(i,j+n,1),4);\n    orimod(i+m,j+n) = mod(qrImage(i+m,j+n,1),4);\n\n    qrImage1(i,j,1) = qrImage(i,j,1)-orimod(i,j);\n    qrImage1(i+m,j,1) = qrImage(i+m,j,1)-orimod(i+m,j);\n    qrImage1(i,j+n,1) = qrImage(i,j+n,1)-orimod(i,j+n);\n    qrImage1(i+m,j+n,1) = qrImage(i+m,j+n,1)-orimod(i+m,j+n);\n\n    k1 = fix(watermarkImage(i,j));\n    k2 = fix(k1/4);\n    k3 = fix(k2/4);\n    k4 = fix(k3/4);\n\n    multiwatermarkImage(i,j) = mod(k1,4);\n    multiwatermarkImage(i+m,j) = mod(k2,4);\n    multiwatermarkImage(i,j+n) = mod(k3,4);\n    multiwatermarkImage(i+m,j+n) = mod(k4,4);\n\n    qrImage2(i,j,1) = qrImage1(i,j,1) + multiwatermarkImage(i,j);\n    qrImage2(i+m,j,1) = qrImage1(i+m,j,1) + multiwatermarkImage(i+m,j);\n    qrImage2(i,j+n,1) = qrImage1(i,j+n,1) + multiwatermarkImage(i,j+n);\n    qrImage2(i+m,j+n,1) = qrImage1(i+m,j+n,1) + multiwatermarkImage(i+m,j+n);\n  end\nend\n\nQrImagewithwatermarkImage=qrImage2;\nfigure;\nimshow(QrImagewithwatermarkImage);\ntitle('the image with water marks!');\n```\nNow we can see the QRcode image with watermark.\n![figure 4](/images/thesis/4.jpg)\n### Step3: Decoding\nUse the same algorithm to decode the image with watermark. Then get the reversed fingerprint image.\n```matlab\nfor i=1:m\n  for j=1:n\n    x1 = mod(QrImagewithwatermarkImage(i,j,1),4);\n    x2 = mod(QrImagewithwatermarkImage(i+m,j,1),4);\n    x3 = mod(QrImagewithwatermarkImage(i,j+n,1),4);\n    x4 = mod(QrImagewithwatermarkImage(i+m,j+n,1),4);\n\n    newwatermark(i,j) = x1 + x2*4 + x3*16 + x4*64;\n  end\nend\nnewwatermark2 = uint8(newwatermark);\nfigure;\nimshow(newwatermark2);\ntitle('the watermark!');\n```\n![figure 5](/images/thesis/5.jpg)\n","source":"_posts/4Security-Strategy.md","raw":"title: 4. Security Strategy\ndate: 2015-06-24 18:19:43\ncategories: Thesis\ntags: thesis\ntoc: true\n---\n# Chapter 4 Security Strategy\nThis chapter discuss the security strategy in the fingerprint authentication system. First, we will talk about security threat briefly; Second, we discuss the traditional approach to enhance security; Third, we give a fingerprint watermark approach to solve the security problems. We will discuss reversible watermarking technology in this part.\n## 4.1 Security Threat and Common Approach\n### 4.1.1 Security Threat\nAs we have talked in chapter 1, there are some types of internet attack. One is to **intercept information**. The purpose of intercepting information is to steal data content itself. Another one is to **replay attack**. Replay attack is a form of network attack in which a valid data transmission is maliciously or fraudulently repeated or delayed. In our system, attackers will try to intercept user’s packages which contain fingerprint images. This is a kind of intercept attack. In this case, user information will be leaked. In addition, the attackers intercept data packages then they can resend these data packages to the server regardless of whether the data is encrypted. This is a kind of replay attack. Attackers use replay attack to realize the purpose of spoofing server. Then the server will consider the attacker to be the original user.\n\nThe fingerprint authentication system should be security. We try to design some security subsystem to enhance the system security. Then the system should be prevent information interception and replay attack.\n### 4.1.2 Common Approach\nFile encryption and digital signature is a common approach to enhance system security.\n* File encryption : Prevent information leaks.\n* Digital signature : Ensure the message sent by the original sender.\n\nFile encryption： The basic process flow of file encryption is to encode the original file by an algorithm, making it unreadable(commonly referred to as “ciphertext”). The original file cannot be displayed without **key**. By this way we can prevent data from being illegally stolen. The reverse process is called decryption. such as: [Algorithm 1](http://blog.csdn.net/stpeace/article/details/8315772) and [Algorithm 2](http://wenku.baidu.com/link?url=Szecji7gvHr35DDq2ltqNqa4aYdajxnfNinz8WA3_4WWVXKHgj6IFUvjTgY_V-w9eqcz4YppASDBfejSm0cIMGMZA62YlXNME9e2ZfxwVoK)\n\nDigital signature: A digital signature is a mathematical technique used to validate the authenticity and integrity of a message, software or digital document. see [searchsecurity](http://searchsecurity.techtarget.com/definition/digital-signature). The basic flow of digital signature is like this:\n![figure 1](/images/thesis/1.png)\nFrom this diagram, we can know how digital-signature works. First, the data sender uses his private key to encode the information he prepared to send, then he gets a signed message. Second, he send the signed message to the receiver. The receiver gets the signed message and decodes the message by the sender’s public key. Then the receiver gets the decrypted hash. If the decrypted hash matches a second computed hash of the same data, it proves that the data hasn’t changed since it was signed. Otherwise, it proves that the data has been changed by attackers since it was signed.\n### 4.1.3 New Approach\nThe traditional approach is good enough to enhance system security and prevent internet attack. However, there are still some disadvantages to apply it to our fingerprint system.\n1. **Complex**. Digital-signature need to be controlled in a complex architecture. Besides, we need to build two separate subsystems, one is for file encryption, the other one is for digital signature. It will be more complex.\n2. **Common Approach**. It is a common approach to enhance system security. It does not take into account the characteristics of the fingerprint image.\n\nIn order to overcome the two drawbacks, we try to propose a new approach. The new approach is a kind of reversible digital watermark technology and it combine file encryption with authentication. We will discuss the detail in 4.3 Solution and 4.4 Algorithm.\n\n## 4.2 Architecture\n\nWaiting to write ...\n\n## 4.3 Solution\n\nWaiting to write ...\n\n## 4.4 Algorithm\n\nWaiting to write ...\n\n### Step1: Read and display\nDisplay the QrCode image and fingerprint image. use fingerprint image as watermark.\n```matlab\nclear;\nclc;\n\n%= Read the QRCode and FP watermarkImage\nqrImage = imread('qrImage.png');\nfpImage = imread('watermarkImage.bmp');\nwatermarkImage = double(fpImage);\n\nfigure;\nimshow(qrImage);\ntitle('the qrCode Image!');\n\nfigure;\nimshow(uint8(watermarkImage));\ntitle('the image with water marks!');\n```\nThen the QR Code Image and fingerprint image are displayed.\n![figure 2](/images/thesis/2.jpg)\n![figure 3](/images/thesis/3.jpg)\n### Step2: Encoding\nUse the algorithm below to encode the QRcode with fingerprint image.\n```matlab\n[m,n] = size(watermarkImage);\nnewwatermark=zeros(m,n);\nnewwatermark2 = zeros(m,n);\nmultiwatermarkImage = zeros(2*m,2*n);\norimod = zeros(2*m,2*n);\n\nqrImage1 = qrImage;\nqrImage2 = qrImage;\n\nfor i=1:m\n  for j=1:n\n    orimod(i,j)=mod(qrImage(i,j,1),4);\n    orimod(i+m,j) = mod(qrImage(i+m,j,1),4);\n    orimod(i,j+n) = mod(qrImage(i,j+n,1),4);\n    orimod(i+m,j+n) = mod(qrImage(i+m,j+n,1),4);\n\n    qrImage1(i,j,1) = qrImage(i,j,1)-orimod(i,j);\n    qrImage1(i+m,j,1) = qrImage(i+m,j,1)-orimod(i+m,j);\n    qrImage1(i,j+n,1) = qrImage(i,j+n,1)-orimod(i,j+n);\n    qrImage1(i+m,j+n,1) = qrImage(i+m,j+n,1)-orimod(i+m,j+n);\n\n    k1 = fix(watermarkImage(i,j));\n    k2 = fix(k1/4);\n    k3 = fix(k2/4);\n    k4 = fix(k3/4);\n\n    multiwatermarkImage(i,j) = mod(k1,4);\n    multiwatermarkImage(i+m,j) = mod(k2,4);\n    multiwatermarkImage(i,j+n) = mod(k3,4);\n    multiwatermarkImage(i+m,j+n) = mod(k4,4);\n\n    qrImage2(i,j,1) = qrImage1(i,j,1) + multiwatermarkImage(i,j);\n    qrImage2(i+m,j,1) = qrImage1(i+m,j,1) + multiwatermarkImage(i+m,j);\n    qrImage2(i,j+n,1) = qrImage1(i,j+n,1) + multiwatermarkImage(i,j+n);\n    qrImage2(i+m,j+n,1) = qrImage1(i+m,j+n,1) + multiwatermarkImage(i+m,j+n);\n  end\nend\n\nQrImagewithwatermarkImage=qrImage2;\nfigure;\nimshow(QrImagewithwatermarkImage);\ntitle('the image with water marks!');\n```\nNow we can see the QRcode image with watermark.\n![figure 4](/images/thesis/4.jpg)\n### Step3: Decoding\nUse the same algorithm to decode the image with watermark. Then get the reversed fingerprint image.\n```matlab\nfor i=1:m\n  for j=1:n\n    x1 = mod(QrImagewithwatermarkImage(i,j,1),4);\n    x2 = mod(QrImagewithwatermarkImage(i+m,j,1),4);\n    x3 = mod(QrImagewithwatermarkImage(i,j+n,1),4);\n    x4 = mod(QrImagewithwatermarkImage(i+m,j+n,1),4);\n\n    newwatermark(i,j) = x1 + x2*4 + x3*16 + x4*64;\n  end\nend\nnewwatermark2 = uint8(newwatermark);\nfigure;\nimshow(newwatermark2);\ntitle('the watermark!');\n```\n![figure 5](/images/thesis/5.jpg)\n","slug":"4Security-Strategy","published":1,"updated":"2015-07-09T09:27:57.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03gf3000on8sv9kvqldkg"},{"title":"3. System Architecture","date":"2015-06-26T09:33:45.000Z","toc":true,"_content":"\n# Chapter 3 System Architecture\n本章介绍系统总体业务逻辑与架构选择。本章分为2部分，第一部分介绍系统总体业务流程，第二部分阐述跨平台服务器端框架及其工作原理。\n\n## 3.1 Basic Business Process\n### 3.1.1 Business Component\n业务组件包含4部分：\n1. **客户端**: 包含Android智能手机，指纹图片采集模块，特征提取模块，加密模块；\n\n2. **服务器端**: 包含Web Sever，解密模块，认证模块，指纹匹配模块；\n\n3. **第三方组件**: 包含Fingerprint Matcher SDK；\n\n4. **数据库**: 包含指纹图像数据库，用户数据库等。\n\n### 3.1.2 Business Flow\n系统总体业务流程如下图所示：\n![业务流程图](/images/thesis/chapter3/1.bmp)\n系统业务流程包含以下几个过程：\n1. **指纹图像采集**: 用户使用Android手机登录客户端，客户端调用照相机和图像采集模块采集用户指纹图像。\n\n2. **图像预处理与特征提取**: 客户端调用特征提取模块对采集到的指纹对象进行预处理，图像增强与特征提取。\n\n3. **图像加密**: 客户端首先接收服务器端发送的QRCode验证信息，然后调用加密模块利用二维码对指纹图像进行加密。\n\n4. **图像上传**: 客户端调用Web API，将加密后的指纹图像上传到服务器端，实现指纹信息的安全传输。\n\n5. **图像解密**: 服务器端调用解密模块对加密的指纹图片进行解密，解密后同时取得验证二维码信息和指纹图像原图片。\n\n6. **用户认证**: 服务器根据解密后得到的二维码认证信息对用户进行认证，确保用户的真实性。\n\n7. **指纹匹配**: 服务器端调用Matcher SDK对用户上传的指纹图片与指纹数据库的图片的对比，获取指纹匹配分数。\n\n8. **验证结果显示**: 服务器将指纹匹配分数返回给客户端，客户端根据匹配分数决定用户认证是否通过。\n\n## 3.2 Architecture Design\n### 3.2.1 Object\n// waiting to write. (First review something about MVC, Web Service and Nancy, then write this part.)\n### 3.2.2 Web Service\n// same as 3.2.1\n### 3.2.3 Nancy Framework\n// same as 3.2.1 \n","source":"_posts/3System-Architecture.md","raw":"title: 3. System Architecture\ndate: 2015-06-26 18:33:45\ncategories: Thesis\ntags: thesis\ntoc: true\n---\n\n# Chapter 3 System Architecture\n本章介绍系统总体业务逻辑与架构选择。本章分为2部分，第一部分介绍系统总体业务流程，第二部分阐述跨平台服务器端框架及其工作原理。\n\n## 3.1 Basic Business Process\n### 3.1.1 Business Component\n业务组件包含4部分：\n1. **客户端**: 包含Android智能手机，指纹图片采集模块，特征提取模块，加密模块；\n\n2. **服务器端**: 包含Web Sever，解密模块，认证模块，指纹匹配模块；\n\n3. **第三方组件**: 包含Fingerprint Matcher SDK；\n\n4. **数据库**: 包含指纹图像数据库，用户数据库等。\n\n### 3.1.2 Business Flow\n系统总体业务流程如下图所示：\n![业务流程图](/images/thesis/chapter3/1.bmp)\n系统业务流程包含以下几个过程：\n1. **指纹图像采集**: 用户使用Android手机登录客户端，客户端调用照相机和图像采集模块采集用户指纹图像。\n\n2. **图像预处理与特征提取**: 客户端调用特征提取模块对采集到的指纹对象进行预处理，图像增强与特征提取。\n\n3. **图像加密**: 客户端首先接收服务器端发送的QRCode验证信息，然后调用加密模块利用二维码对指纹图像进行加密。\n\n4. **图像上传**: 客户端调用Web API，将加密后的指纹图像上传到服务器端，实现指纹信息的安全传输。\n\n5. **图像解密**: 服务器端调用解密模块对加密的指纹图片进行解密，解密后同时取得验证二维码信息和指纹图像原图片。\n\n6. **用户认证**: 服务器根据解密后得到的二维码认证信息对用户进行认证，确保用户的真实性。\n\n7. **指纹匹配**: 服务器端调用Matcher SDK对用户上传的指纹图片与指纹数据库的图片的对比，获取指纹匹配分数。\n\n8. **验证结果显示**: 服务器将指纹匹配分数返回给客户端，客户端根据匹配分数决定用户认证是否通过。\n\n## 3.2 Architecture Design\n### 3.2.1 Object\n// waiting to write. (First review something about MVC, Web Service and Nancy, then write this part.)\n### 3.2.2 Web Service\n// same as 3.2.1\n### 3.2.3 Nancy Framework\n// same as 3.2.1 \n","slug":"3System-Architecture","published":1,"updated":"2015-07-09T09:27:57.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03gfp000rn8sv36kci1fr"},{"title":"1. Introduction","date":"2015-06-22T08:55:14.000Z","toc":true,"_content":"# Chapter 1 Introduction\n## 1.1 Fingerprint Authentication System\nFingerprint identification system is an important identity authentication system. It will be more and more important in modern society. Traditional fields such as security system, access control system must use this technology. With the rise of the mobile Internet, more and more emerging fields such as e-commerce, electronic payment also need this technology.\n\nThe traditional fingerprint recognition system adopts the following technical architecture:\n![figure 1](/images/1.png)\nThe business process is as follows:\n1. Users press the fingerprints on the fingerprints sensor.\n2. The sensor is connected to the computer system and sends the user’s fingerprints directly to the computer system.\n3. The similarity of fingerprint data between user and database will be compared.\n4. The fingerprint authentication system judges whether the user is authenticated by the similarity and returns the result to the user.\n\nHowever, with the rise of mobile Internet, the drawbacks of this traditional fingerprint authentication system were exposed. First is security issue, the user fingerprint data stored directly in the system computer, user’s fingerprint image information is easy to be stolen; Second is usability and cost issues, the traditional fingerprint system requires sensor to input users’ fingerprints and the system deployment requires a separate terminal hardware and terminal software. All these lead to increased costs and decreased usability. Third is a scalability issue, the architecture of host-database is not easy to extend. Once scenarios need to use the system, we must purchase the corresponding hardware and software, leading to poor scalability.\n\nIn this paper, the drawbacks of traditional fingerprint identification system has been improved and reorganized. We developed a web-based fingerprint authentication system using smartphone, and used a number of security defense strategies to enhance the security of the system. Finally, the new approach can solve the security, usability, cost and scalability issues in the traditional fingerprint identification system.\nSystem architecture is as follows:\n![figure 2](/images/2.png)\nThe innovation of the system is:\n1. Using smartphone camera instead of the traditional fingerprint sensor, to solve the cost and usability issues.\n2. Using Web Service to provide cross-platform service to solve the cost and scalability issues.\n3. Using enhanced security defense strategy, to solve the security issue.\n\nThis paper focuses on the server solution based on enhanced security strategy.\n## 1.2 Security Threat\nThe following security threat will occur in the web-based fingerprint authentication system:\n### 1.2.1 Intercept Information\nThe purpose of intercepting information is to steal data content itself. This type of security threat is commonly referred to as data security threats. In the fingerprint authentication system, client needs to send the fingerprint image file to the server through network. During transmission, once the system is attacked, it may cause the fingerprint image data to be intercepted, and then the user information will be stolen.\n![figure 3](/images/3.png)\n### 1.2.2 Replay attack\nDestroying the validity of certification is a basic form of authentication attack. A replay attack is a form of network attack in which a valid data transmission is maliciously or fraudulently repeated or delayed. This is carried out either by the originator or by an adversary who intercepts the data and retransmits it, possibly as part of a masquerade attack by IP packet substitution.\n\nThe classic example of replay attack is as follows:\n![figure 4](/images/4.png)\nSuppose Alice wants to prove her identity to Bob. Bob requests her password as proof of identity, which Alice dutifully provides (possibly after some transformation like a hash function); meanwhile, Eve is eavesdropping on the conversation and keeps the password (or the hash). After the interchange is over, Eve (posing as Alice) connects to Bob; when asked for a proof of identity, Eve sends Alice’s password (or hash) read from the last session, which Bob accepts thus granting access to Eve.\n![figure 5](/images/5.png)\n### 1.2.3 Data Modification\nThis type of network attacks is an extension of replay attack. Attackers using replay attack damage the system certification to enter the system. Then they can send the forged data to the server easily. And even they will do SQL injection attacks or modify server information. The basic model is as follows:\n![figure 6](/images/6.png)\n## 1.3 Defense Strategy\n### 1.3.1 Image Encryption\nFor attacks in 1.2.1, the usual defense strategy is image encryption. Before the client sends the image file, we can use a specific algorithm to encrypt image. Then client sends the file to the server. After the server receives the file, we will use the same algorithm to decrypt the image. In this case, even if attackers intercept the image file, he still cannot get the real information, thus preventing information leakage.\n![figure 7](/images/7.png)\n### 1.3.2 Timestamp Authentication\nIt is efficient defense against replay attack to add timestamp to the system. To use this approach, we should ensure synchronization between client and server. First, the server generates a dynamic password from time to time. Second, the client sends a request to get the dynamic password. Finally, client sends username and dynamic password to login system. In this case, even if the middle man steal the password, it is only effective in a very short time.\n![figure 8](/images/8.png)\n### 1.3.3 Challenge-Response Authentication\nChallenge-Response Authentication is another effective method to prevent replay attack. The basic model is as follows:\n1. Client sends a request to login. (We can assume it is ‘GET’ request)\n2. Server generates a random number K=random (NUM), then return K to Client. Besides, server should save K to the session.\n3. Client calculates R=Hmac(K, P), then sends the result to the server. In the formula, K represents key (the random number), P represents user password, Hmac() is a Hash Function.\n4. Server gets the user password from database and does the same calculation R’=hmac() as step 3. Then comparing R’ with R, if R’ equals R, users will login system successfully.\n\nIn this process, the man in the middle can only get K and R, but K is a random number while R is a hash result, the two numbers are both meaningless. Attackers cannot get user password through the two numbers. System security is improved.\n![figure 9](/images/9.png)\n## 1.4 Fingerprint Authentication System with Enhanced Security\nThe paper discusses a fingerprint authentication system with enhanced security. First, we will use the new approach to instead of the traditional approach, we will not use fingerprint sensor to get user fingerprint data. Instead, we use smartphone camera to get the user information. It will be more convenient and low cost. Second, we use Web Service to provide web-based authentication service with enhanced security. We use some methods to improve the system security and prevent network attack. Finally, we will realize a new fingerprint authentication system with convenience, security and low cost.\n\nThe paper will be divided into 7 chapters.\nChapter 1 expresses the problems of the existed fingerprints authentication system and gives a new approach to solve the problems.\nChapter 2 introduces the related work of fingerprints system and system security.\nChapter 3 gives the system architecture to show how it works.\nChapter 4 discusses the security strategy to prevent network attack.\nChapter 5 discusses fingerprints matcher web service.\nChapter 6 I have no idea now.\nChapter 7 gives the conclusion.\n","source":"_posts/1Introduction.md","raw":"title: 1. Introduction\ndate: 2015-06-22 17:55:14\ncategories: Thesis\ntags: thesis\ntoc: true\n---\n# Chapter 1 Introduction\n## 1.1 Fingerprint Authentication System\nFingerprint identification system is an important identity authentication system. It will be more and more important in modern society. Traditional fields such as security system, access control system must use this technology. With the rise of the mobile Internet, more and more emerging fields such as e-commerce, electronic payment also need this technology.\n\nThe traditional fingerprint recognition system adopts the following technical architecture:\n![figure 1](/images/1.png)\nThe business process is as follows:\n1. Users press the fingerprints on the fingerprints sensor.\n2. The sensor is connected to the computer system and sends the user’s fingerprints directly to the computer system.\n3. The similarity of fingerprint data between user and database will be compared.\n4. The fingerprint authentication system judges whether the user is authenticated by the similarity and returns the result to the user.\n\nHowever, with the rise of mobile Internet, the drawbacks of this traditional fingerprint authentication system were exposed. First is security issue, the user fingerprint data stored directly in the system computer, user’s fingerprint image information is easy to be stolen; Second is usability and cost issues, the traditional fingerprint system requires sensor to input users’ fingerprints and the system deployment requires a separate terminal hardware and terminal software. All these lead to increased costs and decreased usability. Third is a scalability issue, the architecture of host-database is not easy to extend. Once scenarios need to use the system, we must purchase the corresponding hardware and software, leading to poor scalability.\n\nIn this paper, the drawbacks of traditional fingerprint identification system has been improved and reorganized. We developed a web-based fingerprint authentication system using smartphone, and used a number of security defense strategies to enhance the security of the system. Finally, the new approach can solve the security, usability, cost and scalability issues in the traditional fingerprint identification system.\nSystem architecture is as follows:\n![figure 2](/images/2.png)\nThe innovation of the system is:\n1. Using smartphone camera instead of the traditional fingerprint sensor, to solve the cost and usability issues.\n2. Using Web Service to provide cross-platform service to solve the cost and scalability issues.\n3. Using enhanced security defense strategy, to solve the security issue.\n\nThis paper focuses on the server solution based on enhanced security strategy.\n## 1.2 Security Threat\nThe following security threat will occur in the web-based fingerprint authentication system:\n### 1.2.1 Intercept Information\nThe purpose of intercepting information is to steal data content itself. This type of security threat is commonly referred to as data security threats. In the fingerprint authentication system, client needs to send the fingerprint image file to the server through network. During transmission, once the system is attacked, it may cause the fingerprint image data to be intercepted, and then the user information will be stolen.\n![figure 3](/images/3.png)\n### 1.2.2 Replay attack\nDestroying the validity of certification is a basic form of authentication attack. A replay attack is a form of network attack in which a valid data transmission is maliciously or fraudulently repeated or delayed. This is carried out either by the originator or by an adversary who intercepts the data and retransmits it, possibly as part of a masquerade attack by IP packet substitution.\n\nThe classic example of replay attack is as follows:\n![figure 4](/images/4.png)\nSuppose Alice wants to prove her identity to Bob. Bob requests her password as proof of identity, which Alice dutifully provides (possibly after some transformation like a hash function); meanwhile, Eve is eavesdropping on the conversation and keeps the password (or the hash). After the interchange is over, Eve (posing as Alice) connects to Bob; when asked for a proof of identity, Eve sends Alice’s password (or hash) read from the last session, which Bob accepts thus granting access to Eve.\n![figure 5](/images/5.png)\n### 1.2.3 Data Modification\nThis type of network attacks is an extension of replay attack. Attackers using replay attack damage the system certification to enter the system. Then they can send the forged data to the server easily. And even they will do SQL injection attacks or modify server information. The basic model is as follows:\n![figure 6](/images/6.png)\n## 1.3 Defense Strategy\n### 1.3.1 Image Encryption\nFor attacks in 1.2.1, the usual defense strategy is image encryption. Before the client sends the image file, we can use a specific algorithm to encrypt image. Then client sends the file to the server. After the server receives the file, we will use the same algorithm to decrypt the image. In this case, even if attackers intercept the image file, he still cannot get the real information, thus preventing information leakage.\n![figure 7](/images/7.png)\n### 1.3.2 Timestamp Authentication\nIt is efficient defense against replay attack to add timestamp to the system. To use this approach, we should ensure synchronization between client and server. First, the server generates a dynamic password from time to time. Second, the client sends a request to get the dynamic password. Finally, client sends username and dynamic password to login system. In this case, even if the middle man steal the password, it is only effective in a very short time.\n![figure 8](/images/8.png)\n### 1.3.3 Challenge-Response Authentication\nChallenge-Response Authentication is another effective method to prevent replay attack. The basic model is as follows:\n1. Client sends a request to login. (We can assume it is ‘GET’ request)\n2. Server generates a random number K=random (NUM), then return K to Client. Besides, server should save K to the session.\n3. Client calculates R=Hmac(K, P), then sends the result to the server. In the formula, K represents key (the random number), P represents user password, Hmac() is a Hash Function.\n4. Server gets the user password from database and does the same calculation R’=hmac() as step 3. Then comparing R’ with R, if R’ equals R, users will login system successfully.\n\nIn this process, the man in the middle can only get K and R, but K is a random number while R is a hash result, the two numbers are both meaningless. Attackers cannot get user password through the two numbers. System security is improved.\n![figure 9](/images/9.png)\n## 1.4 Fingerprint Authentication System with Enhanced Security\nThe paper discusses a fingerprint authentication system with enhanced security. First, we will use the new approach to instead of the traditional approach, we will not use fingerprint sensor to get user fingerprint data. Instead, we use smartphone camera to get the user information. It will be more convenient and low cost. Second, we use Web Service to provide web-based authentication service with enhanced security. We use some methods to improve the system security and prevent network attack. Finally, we will realize a new fingerprint authentication system with convenience, security and low cost.\n\nThe paper will be divided into 7 chapters.\nChapter 1 expresses the problems of the existed fingerprints authentication system and gives a new approach to solve the problems.\nChapter 2 introduces the related work of fingerprints system and system security.\nChapter 3 gives the system architecture to show how it works.\nChapter 4 discusses the security strategy to prevent network attack.\nChapter 5 discusses fingerprints matcher web service.\nChapter 6 I have no idea now.\nChapter 7 gives the conclusion.\n","slug":"1Introduction","published":1,"updated":"2015-07-09T09:27:57.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03gfs000un8svkj6oaygu"},{"title":"Javascript 每日练习-1","date":"2015-07-08T15:29:02.000Z","_content":"### Q1:创建一个记录学生成绩的对象，提供一个添加成绩的方法，以及一个显示学生平均成绩的方法。\n```javascript\nfunction Grade() {\n  this.dataStore = [];\n  this.add = add;\n  this.displayAvg = displayAvg;\n}\n\nfunction add(score) {\n  this.dataStore.push(score);\n}\n\nfunction displayAvg() {\n  var avg;\n  var sum = 0;\n  for(var i=0; i<this.dataStore.length; ++i) {\n    sum += this.dataStore[i];\n  }\n  avg = sum / this.dataStore.length;\n  print(avg.toFixed(2));\n}\n\nvar grade = new Grade();\ngrade.add(80);\ngrade.add(70);\ngrade.add(60);\ngrade.add(100);\ngrade.displayAvg();\n```\n### Q2:将一组单词存储在一个数组中，并按正序和倒序分别显示这些单词。\n```javascript\nvar words = [\"hello\",\"java\",\"js\",\"csharp\",\"cplusplus\",\"python\"];\nwords.sort();\nprint(words);\nwords.reverse();\nprint(words);\n```\n### Q3:修改本章前面出现过的weeklyTemps对象，使它可以使用一个二维数组来存储每月的有用数据。增加一些方法用以显示月平均数、具体某一周平均数和所有周的平均数\n```javascript\n//修改本章前面出现过的weeklyTemps对象，使它可以使用一个二维数组来存储每月的有用数据。\n//增加一些方法用以显示月平均数、具体某一周平均数和所有周的平均数。\nfunction weekTemps(data) {\n    this.dataStore = data;\n    this.add = add;\n    this.monthaverage = monthaverage;\n    this.weekaverage = weekaverage;\n}\nfunction add(week,temp) {\n    this.dataStore[week-1].push(temp);\n}\nfunction monthaverage() {\n    var total = 0;\n    var day = 0;\n    for (var row = 0; row < this.dataStore.length; ++row) {\n        for(var col = 0; col < this.dataStore[row].length; ++col) {\n          total += this.dataStore[row][col];\n          ++day;\n        }\n    }\n    return (total / day).toFixed(2);\n}\nfunction weekaverage() {\n  var total = 0;\n  var avg = [];\n  for (var row = 0; row < this.dataStore.length; ++row) {\n    total = 0;\n    for(var col = 0; col < this.dataStore[row].length; ++col) {\n      total += this.dataStore[row][col];\n    }\n    avg[row] = total/this.dataStore[row].length;\n  }\n  return avg;\n}\n\nvar data = [];\nfor(var i=0; i<5; i++) {\n   data[i] = [];\n}\nvar temps = new weekTemps(data);\ntemps.add(1,20);\ntemps.add(1,22);\ntemps.add(1,25);\ntemps.add(1,27);\ntemps.add(1,27);\ntemps.add(1,27);\ntemps.add(1,25);\ntemps.add(2,26);\ntemps.add(2,20);\ntemps.add(2,20);\ntemps.add(2,19);\ntemps.add(2,17);\ntemps.add(2,20);\ntemps.add(2,22);\ntemps.add(3,24);\ntemps.add(3,23);\ntemps.add(3,25);\ntemps.add(3,25);\ntemps.add(3,27);\ntemps.add(3,27);\ntemps.add(3,28);\ntemps.add(4,30);\ntemps.add(4,28);\ntemps.add(4,29);\ntemps.add(4,29);\ntemps.add(4,31);\ntemps.add(4,30);\ntemps.add(4,28);\ntemps.add(5,31);\ntemps.add(5,31);\nprint(\"the average of the month:\");\nprint(temps.monthaverage());\nvar weekavg = temps.weekaverage();\nfor(var i=0; i<weekavg.length; ++i) {\n  print(\"week \"+ parseInt(i+1) + \", average: \"+ weekavg[i]);\n}\n```\n### Q4:创建这样一个对象，它将字母存储在一个数组中，并且用一个方法可以将字母连在一起，显示成一个单词。\n```javascript\nfunction Combine()  {\n  this.words = [];\n  this.add = add;\n  this.connect = connect;\n}\nfunction add(character) {\n  this.words.push(character);\n}\nfunction connect() {\n  var word;\n  word = this.words.join(\"\");\n  return word;\n}\n\nvar myword = new Combine();\nmyword.add(\"H\");\nmyword.add(\"E\");\nmyword.add(\"L\");\nmyword.add(\"L\");\nmyword.add(\"O\");\nprint(myword.connect());\n```\n","source":"_posts/150709-JS.md","raw":"title: Javascript 每日练习-1\ndate: 2015-07-09 00:29:02\ncategories: Javascript\ntags:\n---\n### Q1:创建一个记录学生成绩的对象，提供一个添加成绩的方法，以及一个显示学生平均成绩的方法。\n```javascript\nfunction Grade() {\n  this.dataStore = [];\n  this.add = add;\n  this.displayAvg = displayAvg;\n}\n\nfunction add(score) {\n  this.dataStore.push(score);\n}\n\nfunction displayAvg() {\n  var avg;\n  var sum = 0;\n  for(var i=0; i<this.dataStore.length; ++i) {\n    sum += this.dataStore[i];\n  }\n  avg = sum / this.dataStore.length;\n  print(avg.toFixed(2));\n}\n\nvar grade = new Grade();\ngrade.add(80);\ngrade.add(70);\ngrade.add(60);\ngrade.add(100);\ngrade.displayAvg();\n```\n### Q2:将一组单词存储在一个数组中，并按正序和倒序分别显示这些单词。\n```javascript\nvar words = [\"hello\",\"java\",\"js\",\"csharp\",\"cplusplus\",\"python\"];\nwords.sort();\nprint(words);\nwords.reverse();\nprint(words);\n```\n### Q3:修改本章前面出现过的weeklyTemps对象，使它可以使用一个二维数组来存储每月的有用数据。增加一些方法用以显示月平均数、具体某一周平均数和所有周的平均数\n```javascript\n//修改本章前面出现过的weeklyTemps对象，使它可以使用一个二维数组来存储每月的有用数据。\n//增加一些方法用以显示月平均数、具体某一周平均数和所有周的平均数。\nfunction weekTemps(data) {\n    this.dataStore = data;\n    this.add = add;\n    this.monthaverage = monthaverage;\n    this.weekaverage = weekaverage;\n}\nfunction add(week,temp) {\n    this.dataStore[week-1].push(temp);\n}\nfunction monthaverage() {\n    var total = 0;\n    var day = 0;\n    for (var row = 0; row < this.dataStore.length; ++row) {\n        for(var col = 0; col < this.dataStore[row].length; ++col) {\n          total += this.dataStore[row][col];\n          ++day;\n        }\n    }\n    return (total / day).toFixed(2);\n}\nfunction weekaverage() {\n  var total = 0;\n  var avg = [];\n  for (var row = 0; row < this.dataStore.length; ++row) {\n    total = 0;\n    for(var col = 0; col < this.dataStore[row].length; ++col) {\n      total += this.dataStore[row][col];\n    }\n    avg[row] = total/this.dataStore[row].length;\n  }\n  return avg;\n}\n\nvar data = [];\nfor(var i=0; i<5; i++) {\n   data[i] = [];\n}\nvar temps = new weekTemps(data);\ntemps.add(1,20);\ntemps.add(1,22);\ntemps.add(1,25);\ntemps.add(1,27);\ntemps.add(1,27);\ntemps.add(1,27);\ntemps.add(1,25);\ntemps.add(2,26);\ntemps.add(2,20);\ntemps.add(2,20);\ntemps.add(2,19);\ntemps.add(2,17);\ntemps.add(2,20);\ntemps.add(2,22);\ntemps.add(3,24);\ntemps.add(3,23);\ntemps.add(3,25);\ntemps.add(3,25);\ntemps.add(3,27);\ntemps.add(3,27);\ntemps.add(3,28);\ntemps.add(4,30);\ntemps.add(4,28);\ntemps.add(4,29);\ntemps.add(4,29);\ntemps.add(4,31);\ntemps.add(4,30);\ntemps.add(4,28);\ntemps.add(5,31);\ntemps.add(5,31);\nprint(\"the average of the month:\");\nprint(temps.monthaverage());\nvar weekavg = temps.weekaverage();\nfor(var i=0; i<weekavg.length; ++i) {\n  print(\"week \"+ parseInt(i+1) + \", average: \"+ weekavg[i]);\n}\n```\n### Q4:创建这样一个对象，它将字母存储在一个数组中，并且用一个方法可以将字母连在一起，显示成一个单词。\n```javascript\nfunction Combine()  {\n  this.words = [];\n  this.add = add;\n  this.connect = connect;\n}\nfunction add(character) {\n  this.words.push(character);\n}\nfunction connect() {\n  var word;\n  word = this.words.join(\"\");\n  return word;\n}\n\nvar myword = new Combine();\nmyword.add(\"H\");\nmyword.add(\"E\");\nmyword.add(\"L\");\nmyword.add(\"L\");\nmyword.add(\"O\");\nprint(myword.connect());\n```\n","slug":"150709-JS","published":1,"updated":"2015-07-09T09:27:57.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibw03gfw000xn8sv77m1gb8e"}],"PostAsset":[],"PostCategory":[{"post_id":"cibw03ge60000n8svmzthvu79","category_id":"cibw03geb0001n8svt3xoeg5v","_id":"cibw03ged0004n8svgnugez19"},{"post_id":"cibw03geo0005n8sv13x0s650","category_id":"cibw03geq0006n8svnissgedy","_id":"cibw03geq0008n8svhtwif79l"},{"post_id":"cibw03ger0009n8svb4ytjt18","category_id":"cibw03ges000an8svcxdspqsk","_id":"cibw03get000bn8svgiltlgn4"},{"post_id":"cibw03geu000cn8svrxhcyqmv","category_id":"cibw03ges000an8svcxdspqsk","_id":"cibw03gev000dn8svlecckn5k"},{"post_id":"cibw03gew000en8sv354n15wc","category_id":"cibw03gex000fn8svkmyc54g9","_id":"cibw03gex000hn8sv7m6wxb5r"},{"post_id":"cibw03gey000in8svdo5tchz4","category_id":"cibw03gez000jn8svgp4qi72t","_id":"cibw03gez000ln8svpqokqpc8"},{"post_id":"cibw03gf1000mn8svduakqbxs","category_id":"cibw03gex000fn8svkmyc54g9","_id":"cibw03gf2000nn8svj110nu73"},{"post_id":"cibw03gf3000on8sv9kvqldkg","category_id":"cibw03gex000fn8svkmyc54g9","_id":"cibw03gf3000pn8svi5q58ud4"},{"post_id":"cibw03gfp000rn8sv36kci1fr","category_id":"cibw03gex000fn8svkmyc54g9","_id":"cibw03gfq000sn8svlljw7qck"},{"post_id":"cibw03gfs000un8svkj6oaygu","category_id":"cibw03gex000fn8svkmyc54g9","_id":"cibw03gfu000vn8svuwiqvmbh"},{"post_id":"cibw03gfw000xn8sv77m1gb8e","category_id":"cibw03gez000jn8svgp4qi72t","_id":"cibw03gfy000yn8svqaa64jye"}],"PostTag":[{"post_id":"cibw03ge60000n8svmzthvu79","tag_id":"cibw03geb0002n8sv4ni2qzxc","_id":"cibw03gec0003n8svo5a0gw2b"},{"post_id":"cibw03geo0005n8sv13x0s650","tag_id":"cibw03geb0002n8sv4ni2qzxc","_id":"cibw03geq0007n8sv6tkda6i5"},{"post_id":"cibw03gew000en8sv354n15wc","tag_id":"cibw03geb0002n8sv4ni2qzxc","_id":"cibw03gex000gn8svqzw347a9"},{"post_id":"cibw03gey000in8svdo5tchz4","tag_id":"cibw03geb0002n8sv4ni2qzxc","_id":"cibw03gez000kn8sv63la78hi"},{"post_id":"cibw03gf3000on8sv9kvqldkg","tag_id":"cibw03geb0002n8sv4ni2qzxc","_id":"cibw03gf4000qn8svxbw6zfzm"},{"post_id":"cibw03gfp000rn8sv36kci1fr","tag_id":"cibw03geb0002n8sv4ni2qzxc","_id":"cibw03gfq000tn8svm2h2j20o"},{"post_id":"cibw03gfs000un8svkj6oaygu","tag_id":"cibw03geb0002n8sv4ni2qzxc","_id":"cibw03gfv000wn8svwbq76x0x"}],"Tag":[{"name":"thesis","_id":"cibw03geb0002n8sv4ni2qzxc"}]}}